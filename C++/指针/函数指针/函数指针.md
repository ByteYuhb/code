## 什么是函数指针
[前面一篇文章](https://juejin.cn/post/7185937424516644922)我们讲解了C/C++中关于指针的用法，但是当时局限的是对变量的指针，对函数这块并未讲解，其实函数也是有地址的。

> 在程序中定义一个函数，则编译时系统就会为这段代码分配一段存储空间，这段存储空间的首地址称为函数的地址，且函数名代表的就是这个地址。既然是地址就可以使用一个指针变量来存储这个地址，这个指针变量就就叫做函数指针。

函数指针变量定义方式和普通的变量指针定义方式有一定区别：

**格式：**

```C++
函数返回值类型 (* 指针变量名) (函数参数列表);
例如：int (*p)(int,int)
```
这段代码就定义了一个函数指针变量p，可以用来存储函数的首地址（一般直接使用函数名代替），该函数类型为带两个int形参以及返回值类型为int。

注意：

> (*指针变量名)这个括号不能省略，如果写成了int *p(int,int)，那就不是一个函数指针了，而是一个返回值类型为一个int型指针的函数p。

那么怎么判断一个指针变量是指向变量的指针变量还是指向函数的指针变量呢？

- 1.首先看变量名前面有没有“*”，如果有“*”说明是指针变量；
- 2.其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量。

另外也可以使用引用的方式进行定义：

> 例如：int (*p)(int,int)使用int (&p)(int,int)来定义，读者可以自己去试试。

## 如何使用函数指针

- 1.作为指针变量进行赋值调用
  代码如下：

  ```c++
  int max(int x, int y) {
    	return x >= y ? x : y;
  }
  int min(int x, int y) {
    	return x >= y ? y : x;
  }
  
  void extendsTest::mainTest()
  {	
  	int a = 10, b = 20;
  	int (*p)(int, int);
  	p = max;
  	cout << p(a, b) << endl;
  	p = min;
  	cout << p(a, b) << endl;
  };
  运行结果：
  20
  10
  ```

  

- 2.作为参数进行函数回调

  > 大部分情况下在代码中函数指针是被用来函数回调使用，也就是作为参数传递。

  代码如下：

  ```
  int max(int x, int y) {
  	return x >= y ? x : y;
  }
  int min(int x, int y) {
  	return x >= y ? y : x;
  }
  //指针形式
  void func(int& a,int& b,int (*p)(int,int)) {
  	cout << p(a, b) << endl;
  }
  //引用形式
  void func1(int& a, int& b, int (&p)(int, int)) {
  	cout << p(a, b) << endl;
  }
  
  void extendsTest::mainTest()
  {	
  	int a = 10, b = 20;
  	func(a, b, max);
  	func(a, b, min);
  };
  
  运行结果：
  20
  10
  ```

  本例中将函数指针作为另外一个函数的参数传入，在函数内部调用函数指针指向的函数，**实现了一个函数内部回调的方式，写Java的同学是不是很熟悉呢？**



## 知识拓展

指针是 C/C++的精华，也是 C/C++的难点，没学会指针就是没学会 C/C++。如果你觉得函数指针还能勉强接受的话，可以尝试理解一些更复杂的指针，例如：

```c++
char *(* c[1])(char **p);
char (*(*(*p)(char *))[1])(char *);
```

**以上两个案例如果都能看懂的话，那么99%以上指针都难不倒你了。**

文章不长，但是知识点很关键，我是[小余](https://mp.weixin.qq.com/s?__biz=MzkwODI1NDEwMA==&mid=2247483986&idx=1&sn=57136c9c062caa1026edf9ed35915c2b&chksm=c0cd8ca9f7ba05bfcfadad10bd97006bbb57afdd048c9c46fe57d122af834f569aa9d8df0e48&token=2142008574&lang=zh_CN#rd)，记得订阅哦，我们下期见。