前言
LeakCanary是一款内存检测工具，可以帮助我们在开发测试阶段检测应用中可能出现的内存泄露情况，
LeakCanary有以下几个特点：
1.使用方便，最新版本只需要集成对应的开源库即可，不需要在应用中做任何操作，如果应用发生内存泄露会以logcat和通知栏的形式通知到开发者
2.默认对应用中大对象进行生命周期监听，如果需要针对某个对象进行监听也可以单独调用对应的监听方法进行监听
3.对应用零侵入，集成对应的版本后，对应用的其他功能不会有影响，LeakCanary只专心检测应用中的内存泄露情况
4.不能在生产中使用，生产中可以使用友盟等应用性能监听

对上面列出的几点，我们提出几个针对性问题：
1.LeakCanary内存检测的基本流程
2.LeakCanary是怎么对内存进行监听的
3.LeakCanary是怎么做到0侵入，并实现对特定大对象进行跟踪的
4.LeakCanary为什么不能用于线上

下面就对这几个问题进行讲解：

1.LeakCanary内存检测的基本流程

在讲解基本流程之前我们先来了解内存泄露的原理：
不需要的对象依然被引用，导致对象分配的内存无法被回收，我们就说发生了内存泄露
举个例子：
有个Activity，内部有个Handler全局对象，这个对象是Activity的内部类，这个Handler存有外部类Activity的引用，
调用了Handler.sendMessage后，msg还未执行完毕，这个时候如果Activity调用了onDestroy，那么这个时候由于Handler持有外部类Activity引用，
msg内部有个target会持有这个Handler的引用，最终导致Activity无法释放内存。这个就是经典的Activity内存泄露的情况，
处理方法就是使用静态的Handler并且使用软引用去包裹这个Activity对象

这个使用的是GCRoot的可达性分析：当一个对象到GC Roots没有任何引用链的时候，就说明这个对象是可回收的，反之是不可回收对象，也就是潜在的内存泄露对象
有哪些对象可以作为GCRoots：

虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI（即一般说的Native方法）引用的对象。

有了上面的内存泄露基础知识，我们再来看下LeakCanary的内存检测的基本流程：
1.在应用启动阶段监听对象的生命周期
      
2.监听到内存泄露情况，调用gc
3.如果保留的对象个数达到阈值，再次调用gc
4.如果还有保留的对象，则dump出heap状态
5.分析dump的heap文件，以通知的形式通知开发者
6.开发者点击通知栏，显示内存溢出的引用链情况

2.LeakCanary是怎么对内存进行监听的
LeakCanary使用一个LinkedHashMap保存需要监听的对象，并使用一个ReferenceQueue来监听这个对象，当对象被回收的时候，遍历ReferenceQueue中的对象，
如果对象不为null，说明这个对象呗回收了，删除LinkedHashMap中的对象，最后linkedHashMap中剩下的对象就是没有被回收的对象，潜在的内存泄露对象。




