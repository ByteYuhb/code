Service面试题：
1.两种启动方式的区别：
	生命周期：
	start： onCreate->onStartCommand->onDestroy
	bind: onCreate->onBind->onUnbind->onDestroy
	使用场景：
	start：一般启动的服务是独立运行的，不依赖调用者，调用者也不关心服务启动成功或者失败
	bind：服务是依赖客户端调用的，服务为客户端提供接口服务，通过ipc机制通讯实现远程调用
2.service的启动流程
	A进程调用startService或者bindService，通过AMS的代理类调用到AMS中的启动服务的方法，在调用realStartService之前会判断进程是否启动，
	如果应用进程未启动，则先去请求孵化zygote进程创建进程服务B，创建成功后，发送请求给AMS，AMS收到应用创建成功的请求，重新调用realStartService方法
	最终回调到应用进程的ApplicationThread的创建服务application并启动服务生命周期的过程
3.Service与Activity怎么实现通信
	通过binder机制通讯：
		Activity在服务绑定成功后，会返回一个服务端的代理类，通过这个代理类，内部实现ipc功能，实现远程调用；
		具体是AIDL通讯过程：
		InterfaceXXX xxx = InterfaceXXX.Stub.asInterface(obj)这个obj = BinderProxy(BpBinder(handle))
		xxx在使用过程中会调用transact方法，将需要发送的数据放到Parcel中，实际调用的是BinderProxy = transact
		最后会调用到BpBinder的BpBinder->transact方法，IPCThreadState::self()->transact,最终调用到驱动中，驱动通过传入的handle找到对应的binder_ref，通过binder_ref找到binder_node，
		通过binder_node找到binder_proc，并将数据放到binder_proc下面的线程池里面的某个线程的todo链表中，并唤醒线程，服务端在接收到数据之后，解析数据，根据code调用对应的服务实例的方法
		
4.IntentService是什么,IntentService原理，应用场景及其与Service的区别
	参考IntentService详解
	1.介绍：
	主要实现在服务中使用子线程处理intent请求，如一些耗时操作
	1.服务中 2.子线程中
	1.使用方式
		1.创建一个类继承IntentService
			public void MyIntentService extends IntentService{}
		2.实现父类IntentService的onHandleIntent方法，可以处理客户端传入的intent请求
			public void onHandleIntent(intent){}
		3.客户端调用startService方法传入Intent
	2.原理，源码解析’
	IntentService：
	@Override
    public void onCreate() {
        // TODO: It would be nice to have an option to hold a partial wakelock
        // during processing, and to have a static startService(Context, Intent)
        // method that would launch the service & hand off a wakelock.

        super.onCreate();
		//1.创建HandlerThread
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
        //2.启动这个HandlerThread
		3.thread.start();
		//获取HandlerThread线程的looper
        4.mServiceLooper = thread.getLooper();
		5.新建一个Handler并传入之前创建的HandlerThread对象的looper
        //mServiceHandler = new ServiceHandler(mServiceLooper);
    }
	
	private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        }
    }
	
	@Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }
	
	@Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }
	
	@Override
    public void onDestroy() {
        mServiceLooper.quit();
    }
	总结：通过上面的源码分析可知：
	1.IntentService是Service的子类
	2.在onCreate方法中默认开启了一个HandleThread，使用这个工作线程一一处理所以启动请求，请求处理完毕后自动停止服务。
	3.只要实现onHandleIntent方法，因为是子线程，可以在这个方法内部做一些耗时的任务。
	4.可以启动多次IntentService，每次请求都会以队列的方式在onHandleIntent方法中执行，所有请求执行完毕之后，才会终止服务

	3.使用场景
	后台下载任务或者静默上传等场景
5.Service 的 onStartCommand 方法有几种返回值?各代表什么意思?
		START_NOT_STICKY
	在执行完 onStartCommand 后,服务被异常 kill 掉,系统不会自动重启该服务
		START_STICKY
	重传 Intent。使用这个返回值时,如果在执行完 onStartCommand 后,服务被异 常 kill 掉,系统会自动重启该服务 ，并
	且onStartCommand方法会执行,onStartCommand方法中的intent值为null。适用于媒体播放器或类似服务。
		START_REDELIVER_INTEN
	使用这个返回值时,服务被异 常 kill 掉,系统会自动重启该服务,并将 Intent 的值传入。
	适用于主动执行应该立即恢复的作业（例如下载文件）的服务。

6.进程保活的方式有哪几种？ adj 提高进程保留优先级方式
    方案1:启动一个像素的Activity保活
		具体：监听屏幕亮屏和暗屏广播，当接收到暗屏时，启动一个透明的一个像素的Activity，在亮屏时，关闭这个Activity
	方案2：调用Service的startForeGround
		具体：api<18 :调用startForeground(NOTIFICATION_ID, new Notification());
			  api>=18:启用一个通知并拉起另外一个服务，另外服务启用通知，并关闭通知，关闭服务，也可以提高进程的优先级
			  2.1调用startForeground(NOTIFICATION_ID, builder.build());
			  2.2并启动一个服务InnerService，在InnerService中startForeground(NOTIFICATION_ID, builder.build())，这个id要和需要保活的服务通知id一致
			  2.3InnerService调用stopForeground(true)和manager.cancel(NOTIFICATION_ID);stopSelf();取消服务
			  
			    Notification.Builder builder = new Notification.Builder(this);
				builder.setSmallIcon(R.mipmap.ic_launcher);
				startForeground(NOTIFICATION_ID, builder.build());
				startService(new Intent(this, InnerService.class));
			
				class InnerService
					startForeground(NOTIFICATION_ID, builder.build()); 通需要保活的NOTIFICATION_ID
					stopForeground(true);
					NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
					manager.cancel(NOTIFICATION_ID);
					stopSelf();
	方案3：相互唤醒，很多互联网应用都使用的这种方式
		A-B：A死了B收到信息唤醒A 
		B-A：B死了A收到信息唤醒B
	方案4：JobSheduler，可以根据间隔时间启动服务
	方案5：粘性服务&与系统服务捆绑
			根据onStartService的返回值
			START_STICKY
			如果系统在onStartCommand返回后被销毁，系统将会重新创建服务并依次调用onCreate和onStartCommand
			START_NOT_STICKY
			如果系统在onStartCommand返回后被销毁，如果返回该值，则在执行完onStartCommand方法后如果Service被杀掉系统将不会重启该服务。
			START_REDELIVER_INTENT
			START_STICKY的兼容版本，不同的是其不保证服务被杀后一定能重启
	方案6：使用NotificationListenerService监听通知栏信息
			监听到信息就重新拉起需要启动的服务
	
	
	1.进程划分：

	1.前台进程：处于前台的进程，用户正在使用的程序，一般不会被杀死，除非
		1.1：Activity处于resume状态的进程
		1.2：某个进程持有一个Service，且该Service正在与用户进程交互的Activity进程绑定
		1.3：某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行
		1.4：某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()
		1.5：某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。
	2.可见进程
		2.1: 最顶层Activity处于onPause状态的进程
		2.2：拥有绑定到可见（或前台）Activity 的 Service
	3.服务进程
		3.1：在后台运行的服务进程
	4.后台进程
		3.1：泛指看不见的一切后台进程
	5.空进程
		5.1：只是一个壳，不包含任何组件，唯一作用是当系统有需要创建进程时，可以直接从空进程转过来。
		
	进程被杀死优先级高低：
		前台->可见->服务进程->后台进程->空进程


	2.内存阈值
		进程是根据什么来杀进程的呢？
		出于性能和用户体验考虑，app在退出到后台时，不会直接杀死进程，而是将其缓存起来，
		当缓存到一定值的时候就会出现内存不足的情况时，最后会根据内存阈值来杀死对应的进程。
		可以根据：
			使用cat /sys/module/lowmemorykiller/parameters/minfree来查看某个手机的内存阈值
		18432,23040,27648,32256,36864,46080
		注意这些数字的单位是page. 1 page = 4 kb.上面的六个数字对应的就是(MB): 72,90,108,126,144,180
		如数180代表内存低于180M时会清除优先级最低的空进程。
	3.adj优先级值
		获取adj：adb shell ps|grep com.android.yuhb.test

			  adb shell cat /proc/21375/oom_adj

		每个等级的进程又有对应的优先级，使用adj值来表示，进程回收机制就是根据这个adj值来进行的
		前台进程adj值最低，代表进程优先级最高，
		空进程adj值越高，最容易被kill
		对于相等优先级的进程：使用的内存越多越容易被杀死
	4.进程保留方案：
		通过上面的分析，进程保活其实就是提高adj进程优先级
		方案一：
		4.1：开启一个像素的Activity
			伪代码：
			1.创建一个像素的Activity
				class onePxActivity
					method：startSelf(context)
								Intent it;
								it.setflag:FLAG_ACTIVITY_NEW_TASK
								context.startActivity
					onCreate
						getWindow
						WindowManager.LayoutParams attributes = window.getAttributes();
						//宽高设计为1个像素
						attributes.width = 1;
						attributes.height = 1;
						//起始坐标
						attributes.x = 0;
						attributes.y = 0;
						window.setAttributes(attributes);
			2.设置Activity的style为透明
				<style name="LiveStyle">
					<item name="android:windowIsTranslucent">true</item>
					<item name="android:windowBackground">@android:color/transparent</item>
					<item name="android:windowAnimationStyle">@null</item>
					<item name="android:windowNoTitle">true</item>
			   </style>

			3.监听开屏和关屏广播去启动和关闭一个像素的Activity
				在哪里监听：
				class mainActivity
				onCreate()
					screenListener.register()
					screenListener.setlistener(interface listener{
						method on(){ }
						method off(){}
					)
					screenManager
				onDestroy()
				screenListener.unregister()
				
				
				
			 
				class screenListener
					interface listener				
					method register （on off）
					field broadcastReceiver
						onReceiver
							if on listener.on
							if off listner.off
				class screenManager
					method startActivity();
					method setActivity()
					method finishActivity()
					
					
		4.2：通过调用Service的startForeGround
			4.2.1:api<18 :
				调用startForeground(NOTIFICATION_ID, new Notification());
			4.2.2:api>=18:
				Notification.Builder builder = new Notification.Builder(this);
				builder.setSmallIcon(R.mipmap.ic_launcher);
				startForeground(NOTIFICATION_ID, builder.build());
				startService(new Intent(this, InnerService.class));
			
				class InnerService
					startForeground(NOTIFICATION_ID, builder.build()); 通需要保活的NOTIFICATION_ID
					handler:
					stopForeground(true);
					NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
					manager.cancel(NOTIFICATION_ID);
					stopSelf();
		4.3:相互唤醒
			A-B：A死了B收到信息唤醒A 
			B-A：B死了A收到信息唤醒B
			
		4.4: JobSheduler
			隔多久启动任务
		4.5：粘性服务&与系统服务捆绑
			START_STICKY
				如果系统在onStartCommand返回后被销毁，系统将会重新创建服务并依次调用onCreate和onStartCommand
			START_NOT_STICKY
				如果系统在onStartCommand返回后被销毁，如果返回该值，则在执行完onStartCommand方法后如果Service被杀掉系统将不会重启该服务。
			START_REDELIVER_INTENT
				START_STICKY的兼容版本，不同的是其不保证服务被杀后一定能重启
				
		4.6:使用NotificationListenerService监听通知栏信息	
			只要手机收到了通知，NotificationListenerService都能监听到,即使用户把进程杀死，也能重启，所以说要是把这个服务放到我们的进程之中
			1.public class LiveService extends NotificationListenerService {}
			2.添加权限BIND_NOTIFICATION_LISTENER_SERVICE
			
			1.介绍：监听通知栏信息
			2.使用方式：
				1.首先创建一个 WeChatNotificationListenerService 继承 NotificationListenerService
				2.在mainfest中声明服务组件和权限
					<service android:name="com.yuqirong.listenwechatnotification.WeChatNotificationListenerService"
					  android:label="@string/app_name"
					  android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">
						 <intent-filter>
							 <action android:name="android.service.notification.NotificationListenerService" />
						 </intent-filter>
					</service>
				3.然后一般会重写下面这三个方法：
					onNotificationPosted(StatusBarNotification sbn) ：当有新通知到来时会回调；比如监听红包等信息
					onNotificationRemoved(StatusBarNotification sbn) ：当有通知移除时会回调；
					onListenerConnected() ：当 NotificationListenerService 是可用的并且和通知管理器连接成功时回调。
				
				4.取消通知方法：
					public void cancelNotification(StatusBarNotification sbn) {
						if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
							cancelNotification(sbn.getKey());
						} else {
							cancelNotification(sbn.getPackageName(), sbn.getTag(), sbn.getId());
						}
					}
				5.检测通知监听服务是否被授权
					public boolean isNotificationListenerEnabled(Context context) {
						Set<String> packageNames = NotificationManagerCompat.getEnabledListenerPackages(this);
						if (packageNames.contains(context.getPackageName())) {
							return true;
						}
						return false;
					}
				6.打开通知监听设置页面
					public void openNotificationListenSettings() {
						try {
							Intent intent;
							if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
								intent = new Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);
							} else {
								intent = new Intent("android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS");
							}
							startActivity(intent);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}

		

