位运算
	右移 >> ：正数补0，负数补1
	左移 << ：正负数都补0
	无符号左移 >>>：正数和负数都补0
	无符号右移 <<<：正数和负数都补0；
对于int值是4个字节：
正数原码反码补码都是一致
负数在计算机中以正数的补码形式存在

正数二进制：
	如int 5：
	二进制：00000000 00000000 00000000 00000101
	5>>2:-> 00000000 00000000 00000000 00000001-->1
	5<<2:-> 00000000 00000000 00000000 00010100-->20

负数二进制：
	如int -3;
	3的二进制：00000000 00000000 00000000 00000011
	反码：	   11111111 11111111 11111111 11111100
	加1：	   11111111 11111111 11111111 11111101-->-3的二进制补码

	-3的二进制补码：11111111 11111111 11111111 11111101
	-3<<2:          11111111 11111111 11111111 11110100
	转原码：符号位不变，其他位取反+1
			取反：	10000000 00000000 00000000 00001011
			加1：	10000000 00000000 00000000 00001100 -->-12
					11111111 11111111 11111111 11110011	
					11111111 11111111 11111111 11110100
补码+反码+1=0



位运算技巧：
1.使用&1和>>>操作可以遍历整个二进制数，如求0或者1的个数
	int res = 0;
	while(n!=0){
		res+=(n&1);
		n>>>=1;无符号位右移，高位补0
	}
2.使用n&(n-1)得到的数字是去掉离低位最近的1；俗称消1法。也可以用来算1的个数
3.对于计算中的加减乘除都是对二进制进行与，或，异或，同或等操作完
	如加法：1+1
	在计算机中：
	假设计算a+b；
	则又假设使用n表示无进位数，c表示进位数
	ai   bi   ni  c(i+1)
	0	 0    0   0
	0	 1    1   0
	1    0    1   0
	1    1    0   1
	观察规律可知：
	ni=ai^bi(异或)
	c(i+1)=(ai&bi)<<1；因为是i+1位需要右移1位；
	最后a+b演化为ni+ci->a^b+(a&b)<<1的问题，循环处理ni和ci当(a&b)<<1==0时，直接返回a^b即可
4.查找数组中出现的不一样的值
	1.假设数组中除了一个值不一样，其他值都是重复m次的情况
		下面思路可以解决：
		对所有二进制的位进行相加得到一串包含所以数字的二进制位的和的情况，然后对每个位对m取余，得到的二进制数既是只出现一次的值的情况
			1.二进制各位相加
			2.二进制各位对m取余
			3.得到的最后的二进制为需要找的结果
			伪代码：
			int[] counts = new int[32];//int值是32位二进制
			//1.二进制各位相加
			for(j=0;int i=0;i<nums.length;i++){
				for(int j=0;j<32;j++){
					counts[j] +=(nums[i]&1);
					nums[i]>>>1;//这里需要使用无符号右移，如果使用有符号右移，对于负数，会出错，因为高位会补1；
				}
			}
			int res =0;
			int m = 3;//其他数字都出现三次
			//2.二进制各位对m取余
			for(int i=0;i<32;i++){
				res<<=1;
				res|=(counts[32-i])%m;//从高位开始取，然后左移
		}
	2.如果是两个不一样的值，如何找出这两个不一样的值，其他数字出现两次。
		1.将两个不一样的数字分配两个数组中。
			如何找到不一样的值。
			将数组中所有的数字进行异或，因为出现的次数是2位偶数，最后得到的异或结果就是两个不同值的异或结果a^b.
			所以只需要找出a^b中哪个位是1的情况，即a和b哪个位不相同的情况，通过这个位将数组分为两个，这样两个不同值a和b就会被分配到两个数组中
			通过对每组异或，每组最后得到的数字就是不同的两个a和b
			
	






		



