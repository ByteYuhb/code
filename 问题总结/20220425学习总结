设计模式：-->状态模式
某些对象会因为有不同的状态从而表现不同的行为，例如线程的生命周期

设计模式-->观察者模式
使用订阅模式

设计模式-->中介者模式
使用一个中介模式，将用户注册到中介类中，实现用户之间低耦合的关系

设计模式-->迭代器模式
使用一个迭代器去遍历数组，链表等数据结构的集合数据


算法：
1.数组中出现超过一半的数值
如1111123411,
知识：
1.可以使用HashMap记录每个数值的个数，取大于一半的那个
2.使用快速排序获取最中间位置的数值也是超过一半的数据
3.使用摩尔投票，对不同的值+1和-1对相同的值+1最后得到的就是最多的那个数值

2.构建乘积数组
观察情况
x 234567
1 x34567
12 x4567
123 x567
1234 x67
12345 x7
1234567x

左三角形和右三角形分数组乘机就可以

3.剪绳子
	使用动态规划，假设剪了一段后（这个一段可以是2到n-1内的数），可以选择不减，也可以选择继续减，只要算出继续减和不减的最大值即可

4.和为s的连续数组
	使用滑动串口。让窗口内部的数组段相加等于t即可
	初始值：i=1，j=2，s=3
	queue ;
	while(i<j){
		if(s>t){
			s-=i;
			i++;
		}else if(s<t){
			s+=(j+1);
			j++
		}else{
			int[] hi = new int[j-i+1];
			int m = i;
			for(int h = 0;h<=j-i;h++){
				hi[h] = m++;
			}
			queue.add(hi);
			s+=(j+1);
			j++;
		}
		return queue.toArray(new int[queue.size][])
	}

5.圆圈中最后剩下的数字
 对0 1 2 3 4 5 6 假设m=3则删除2位置的数值，并将3位置的数值变为0
 找长度为n的时候的元素的位置和长度为n-1的时候的元素的位置
 使用动态规划操作。
 
6.顺时针打印矩阵
	先定位矩阵的上下左右边界
	然后从做到右
	上到下
	右到左
	下到上
	进行遍历，每次遍历完一段需要重新定位边界
7.栈的压入和弹出
	模拟栈的压入和弹出操作
	先把push中的数组压入栈，然后遍历栈顶元素是否和poped元素对比，对比成功，pop出数组，然后将i++，继续遍历push数组，将元素压力栈
	最后判断栈是否为空就可以
8.表示数值的字符串
	输入字符包括正负号（+和-）数字（0-9）小数点（.）幂符号（e或者E）空格（ ）
	1.定义状态
		取一个完整的包括所有组合类型的数据： [ +123.456e+123 ]
		从左到右状态：
		1.初始空格
		2.整数位正负号
		3.整数位
		4.小数点（左边有整数）
		5.小数点（左边无整数）
		6.小数位
		7.幂（e或者E）
		8.幂符号位
		9.幂整数位
		10.结束空格
	
	2.设计状态转移图
	
	3.编码

	
	
	

 
