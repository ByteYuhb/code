Gradle插件
1.定义
首先来讲下Gradle和Gradle插件有啥区别？
Gradle是一套构建工具，其内部构建过程主要是以Project组成一个树形的生态系统，整个构建流程有自己的生命周期。
每个Project又是由若干个Task组成。
而Gradle插件你可以理解为是运行在Gradle这套构建系统上的单个task：如执行脚本的编写，字节码插庄等，都可以依靠Gradle插件实现。
我们常用的Android Gradle Plugin也是一个插件模块：
应用插件的ID：‘com.android.application’
或者lib库：‘com.android.library’
2.有哪些优势
1.逻辑复用:Gradle插件将一个公共模块单独的抽离出来，然后上传到共享平台，供其他项目使用
2.外部配置：Gradle插件声明插件扩展，将插件内部参数暴露给对应的Project进行配置，大大提高了插件的可扩展性。


3.插件的形式
	1.build script：直接在build构建脚本中创建对应的插件，，这种方式只对当前Project有效，不支持对外提供调用，无复用性，一般不推荐使用
	2.buildSrc模块：这种方式是编译器提供的特殊模块，编译器可以自动识别该模块的，对所有的Project可见。但是在项目外不可见，无法给其他工程使用，复用性差。
	3.独立插件项目：替插件创建一个单独的项目，这个项目可以单独的打包成一个jar包，然后发布到企业服务器上供其他项目使用，
		通常这个插件中包含了一个或多个任务的组合，实现具体的插件功能
	
	

4.自定义插件实战
下面我会以第三种形式来大家实现一个简单的插件功能：
在编译过程中实现：将当前编译的版本信息发布到公司服务器上，可以在本地服务器上实时查看编译的版本日志

	1.初始化插件模块目录结构
		首先创建一个java/kotlin library的模块，
		
		在创建的模块build.gradle中引入
		plugins {
			id 'groovy' // Groovy Language
			//id 'org.jetbrains.kotlin.jvm' // Kotlin 
			id 'java-gradle-plugin' // Java Gradle Plugin
		}
		groovy:使用groovy语言开发
		org.jetbrains.kotlin.jvm：使用kotlin开发引入kotlin核心库
		java-gradle-plugin：Gradle插件的一个辅助插件，可以在我们build目录下自动生成资源属性
	
	2.创建插件实现类
		class UploadVersionPlugin implements Plugin<Project>{
			@Override
			void apply(Project project) {
				println "begin:now this is a ${project.name} 's upload plugin"
			}
		}
	3.创建插件扩展Bean
		class VersionInfo {
			//版本名称
			String versionName
			//版本代码
			int versionCode
			//版本更新信息
			String versionUpdateInfo
		}
	4.创建插件实现的任务:上传版本信息
		class UploadTask extends DefaultTask{
			String url = ''
			@TaskAction
			void upload(){
				//1.获取版本信息
				def version = getCurrentVersion()
				//2.发送版本信息
				def response = sendAndReceive(version)
				//3.处理响应：将版本信息以及响应写入到本地文件中
				checkResponse(response)

			}
		}
		记住，在需要执行的方法上面添加TaskAction注解：在我们任务执行的时候就会执行到这个方法。
	5.将插件扩展和插件任务集成到Project生命周期中
		@Override
		void apply(Project project) {
			println "begin:now this is a ${project.name} 's upload plugin"
			//1.在插件中引入extensions中的字段，就是我们Project中配置的扩展字段
			project.extensions.create(EXTENSIVE,VersionInfo.class)
			//2.创建待处理的Task
			project.tasks.create(TASK_NAME,UploadTask.class)
			//3.将uploadTask任务挂架到Project的生命周期中
			def build = project.tasks.getByName('clean')
			def uploadTask = project.tasks.getByName(TASK_NAME)
			//这里使用dependsOn强依赖任务关系
			build.dependsOn(uploadTask)

		}
	
6.插件发布	
	
	笔者为了测试，将jar包只发布在本地，测试使用。
	使用如下方式发布：
	gradlePlugin {
		plugins {
			modularPlugin {
				id = 'com.yuhb.upload'
				implementationClass = 'com.yuhb.upload.UploadVersionPlugin'
			}
		}
	}
	这个方法在build后自动生成resources文件：
	
	当然也可以直接在resources上手动写入该文件
	uploadArchives {
		repositories {
			mavenDeployer {
				repository(url:uri('D:/maven_local'))
				pom.groupId = 'com.yuhb.upload'
				pom.artifactId = 'upload'
				pom.version = '1.0.0'
			}
		}
	}
	在命令行执行：./gradlew :uploadversion:uploadArchives	
	然后去本地文件夹下面看看是否上传成功：
	
	这里要说明下：一般情况下都会将自定义插件发布到maven私服或者中央仓库，才可以供其他项目使用
	关于如何发布到maven私服，可以查看这篇文章
	后期也会出一期文章教大家如何将数据发布到中央仓库
	
7.插件引入
	1.在工程的根build.gradle文件中引入：
	buildscript {
		repositories {
			...
			maven {
				url uri('D:/maven_local')
			}
		}
		dependencies {
			...
			classpath 'com.yuhb.upload:upload:1.0.0'
		}
	}
	说明：
	com.yuhb.upload:upload:1.0.0
	格式：
	com.yuhb.upload对应pom.groupId
	upload对应pom.artifactId
	1.0.0对应pom.version
	2.在子Project中引入插件：
	apply plugin: 'com.yuhb.upload'
	
	3.配置extensive：
	versionInfo {
		versionName = '1.0.0'
		versionCode = 1
		versionUpdateInfo = '当前是第一个版本：初始apk'
	}
	
	这个versionInfo是怎么来的呢？我们看下之前我们配置插件的时候，使用了：
	//1.在插件中引入extensions中的字段，就是我们Project中配置的扩展字段
	EXTENSIVE = 'versionInfo'
	project.extensions.create(EXTENSIVE,VersionInfo.class)
			
			
	就是这里，如果外部配置了versionInfo的扩展字段，就会通过project.extensions获取到，并将数据写入project.extensions的versionInfo属性中：
	之后就可以使用project.extensions的versionInfo属性访问外部传入的配置数据
	
	
	4.运行root的build 任务查看编译信息：
	
	./gradlew build
	
	结果：
	> Task :app:uploadTask
	name:1.0.0 code:1 info:当前是第一个版本：初始apk

	
	这里运行build可以执行插件中的任务是因为前面笔者将插件Task挂接到了build任务之前
	挂接代码：
	//3.将uploadTask任务挂架到Project的生命周期中
        def build = project.tasks.getByName('clean')
        def uploadTask = project.tasks.getByName(TASK_NAME)
        //这里使用dependsOn强依赖任务关系
        build.dependsOn(uploadTask)
	
	项目Demo完整代码已经上传Github：
	
10.总结


参考资料

