> 🔥 **Hi，我是小余。**
>
> **本文已收录到 [GitHub · Androider-Planet](https://github.com/ByteYuhb/Androider-Planet) 中。这里有 Android 进阶成长知识体系，关注公众号 [小余的自习室] ，在成功的路上不迷路！**
## 前言
前面几篇文章我们讲解了一个云音乐app的基础库搭建，今天我们就来对这个app进行**组件化代码重构**

**组件化基础库封装系列文章**如下：

 [Android组件化开发（一）--Maven私服的搭建](https://juejin.cn/post/7118646272323485709)

[ Android组件化开发（二）--网络请求组件封装](https://juejin.cn/post/7119281692350611493)

[Android组件化开发（三）--图片加载组件封装](https://juejin.cn/post/7120791098775044103)

[Android组件化开发（四）--进程保活组件的封装](https://juejin.cn/post/7121643256495996936)

[Android组件化开发（五）--完整版音乐播放组件的封装](https://juejin.cn/post/7122869564299280415)

[Android组件化开发（六）-- 短视频播放组件封装](https://juejin.cn/post/7124609577026322463)

[Android组件化开发（七）--从零开始教你分析项目需求并实现](https://juejin.cn/post/7125471204730732552)


**项目地址**：https://github.com/ByteYuhb/anna_music_app

**项目演示**：

![090223022232_0device-2022-09-02-225448.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93cc7a4f877f4e8dadbe71455fdc90bf~tplv-k3u1fbpfcp-watermark.image?)

## 1.组件化重构效果
这里先看下我们重构前后的框架图比较：

**重构前：**

![传统代码架构.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e0d3ffc5b4b4004ae17d3b86489853f~tplv-k3u1fbpfcp-watermark.image?)

**重构后**

![组件化代码架构.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/634cc4ff439440bb95fc1eb3650384a7~tplv-k3u1fbpfcp-watermark.image?)

- `ft_xxx`表示业务层模块  `lib_xxx`表示基础库模块

**重构后的架构图如下**：

![服务接口调用.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08a8023ea5644e499d57ce69e9067e2a~tplv-k3u1fbpfcp-watermark.image?)
重构前的代码业务封装在宿主app中，业务耦合严重，如果修改一个业务模块，需要对整个app进行完整测试，测试工作量巨大
而**重构后，我们只需要对单一app进行独立调试即可。**

重构后的框架结构：**所有的业务组件之间通讯都通过`ft_base_service`进行通讯**

## 2.组件化重构准则
- 1.**单一业务可以单独调试，也可以作为lib提供给宿主app使用**
- 2.**同一级别的模块不允许直接调用，比如我们的ft_home组件不允许直接调用ft_login组件，不然组件化的意义就不存在了**
- 3.**组件间通讯不能直接使用显示的class文件跳转，可以考虑很用ARouter框架进行解耦**
- 4.**每个组件可打包为aar或者jar上传到maven私服，宿主使用的时候，直接引用私服中aar包即可**

> 能做到以上几点，你的app就可以称为一个组件化框架的app了。
## 3.组件化重构思路

![重构思路.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5fabc7fcd3846129619893cca92af38~tplv-k3u1fbpfcp-watermark.image?)
- 1.**拆**：拆代码，拆资源，拆构建
由于所有业务和资源都耦合在宿主app中，所以需要将代码和资源拆开到对应模块中
当然我们的构建build.gradle也需要拆分到不同模块中
- 2.**接**：对外提供接口
组件化之间不能直接通讯，需要使用暴露接口的方式对外通讯
- 3.**测**：反复测试
重构后代码，需要反复测试，防止出现意想不到的bug

## 4.组件化重构过程
这里我以登录业务`ft_login`为例子：
### 1.**步骤1**：首先新建一个业务模块`ft_login`，然后在宿主app中将登录功能相关联的代码和资源抽离到`ft_login`中
### 2.**步骤2**：将和登录构建相关的依赖分配到`ft_login`构建中。
### 3.**步骤3**：单独调试功能实现

- 3.1:在`gradle.properties`中创建一个全局变量：`isRunAlone=true`

- 3.2:在`build.gradle`中：

```java
if(isRunAlone.toBoolean()){
    apply plugin:'com.android.application'
}else{
    apply plugin:'com.android.library'
}

android {
    compileSdkVersion 33
    buildToolsVersion "33.0.0"

    defaultConfig {
        if(isRunAlone.toBoolean()){
            applicationId 'com.anna.ft_login'
        }
        ...
    }
    sourceSets {
        main {
            java {
                srcDirs = ['src/main/java']
            }
            resources {
                srcDirs = ['src/main/res']
            }
            aidl {
                srcDirs = ['src/main/aidl']
            }
            manifest {
                if(isRunAlone.toBoolean()){
                    srcFile 'src/main/manifest/AndroidManifest.xml'
                }else {
                    srcFile 'src/main/AndroidManifest.xml'
                }
            }
        }
    }
}
def dependList = [rootProject.depsLibs.okhttp,
                  rootProject.depsLibs.gson,
                  rootProject.depsLibs.appcompact,
                  rootProject.depsLibs.design,
                  rootProject.depsLibs.eventbus,
                  rootProject.depsLibs.arouterapi,
                  ':lib_network',':lib_common_ui',':ft_base_service']


dependencies {
    if(!isRunAlone.toBoolean()){
        dependList.each { String depend ->
            depend.startsWithAny(':lib',':ft')? compileOnly(project(depend)):compileOnly(depend){
                switch (depend){
                    case rootProject.depsLibs.arouterapi:
                        exclude group: 'com.android.support'
                        break;
                }
            }
        }
    }else {
        dependList.each { String depend ->
            depend.startsWithAny(':lib',':ft')? implementation(project(depend)):implementation(depend) {
                switch (depend) {
                    case rootProject.depsLibs.arouterapi:
                        exclude group: 'com.android.support'
                        break;
                }
            }
        }
    }
    //arouter注解处理器
    annotationProcessor rootProject.depsLibs.aroutercompiler

    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'

}

```

**单独调试状态下注意四点**：
- 1.引用application插件
- 2.引入applicationId
- 3.引入不同给的sourceSets构建路径
- 4.引入的库单独调试状态下需要使用`implementation`导入，不能使用`compileOnly`

实现上面四点，**只要打开isRunAlone就可作为一个单独app运行了**。


### 4.步骤4：组件间通讯
这里，我们引入一个`ft_base_service`模块，这个模块用来实现组件间通讯用，需要调用别的业务模块都需要使用这个模块才能通讯、
业务模块与`ft_base_service`之间通讯使用的是`路由ARouter`：
关于`ARouter`的使用可以参考这篇文章：

[Android开源系列-组件化框架Arouter-(一)使用方式详解](https://juejin.cn/post/7134326382565261348)
- 1.创建`ft_base_service`，在这个模块中：创建一个`LoginService`接口继承`IProvider`

`引入ARouter依赖`：

```java
android {
	javaCompileOptions {
		annotationProcessorOptions {
			arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: "enable"]
		}
	}
}
//arouter核心api
implementation rootProject.depsLibs.arouterapi
//arouter注解处理器
annotationProcessor rootProject.depsLibs.aroutercompiler
```
**创建LoginService：**

```java
public interface LoginService extends IProvider {
    boolean hasLogin();
    void login(Context context);
}
```
- 2.在`ft_login`业务模块中实现LoginService接口

注意这里因为使用了ARouter注解，所以也需要引入`ARouter`依赖


```java
@Route(path = "/login/login_service")
public class LoginServiceImpl implements LoginService {
    Context context;
    @Override
    public boolean hasLogin() {
        return UserManager.getInstance().hasLogined();
    }

    @Override
    public void login(Context context) {
        LoginActivity.start(context);
    }

    @Override
    public void init(Context context) {
        Log.d("TAG","LoginServiceImpl is init");
    }
}
```
- 3.在`ft_base_service`模块中对`LoginService`接口进行依赖注入

```java
public class LoginImpl {

    @Autowired(name = "/login/login_service")
    public LoginService mLoginService;
    private static LoginImpl mLoginImpl = null;
    public static LoginImpl getInstance() {
        if (mLoginImpl == null) {
            synchronized (LoginImpl.class) {
                if (mLoginImpl == null) {
                    mLoginImpl = new LoginImpl();
                }
                return mLoginImpl;
            }
        }
        return mLoginImpl;
    }

    private LoginImpl(){
        ARouter.getInstance().inject(this);
    }
    public boolean hasLogin(){
        return mLoginService.hasLogin();
    }
    public void login(Context context){
        mLoginService.login(context);
    }

}
```
笔者使用了一个**单例类LoginImpl**，在构造器中对`LoginService`依赖注入

ARouter.getInstance().inject(this);


**然后宿主app或者其他模块引用登录业务功能时，需要依赖`ft_base_service`模块，并使用`LoginImpl`的接口即可。**

> 这里要说明下，平时我们使用的**四大组件跳转**也可以使用这个方式来处理，在服务接口中定义跳转接口即可。当然也可以使用Arouter的Activity跳转方式或者Fragment实例获取方式

- 5.代码打包aar上传到`maven私服`：

关于这块maven私服更多内容可以参考这篇文章：

[Gradle筑基篇(六)-使用Maven实现组件化类库发布](https://juejin.cn/post/7131401057699102728)

这里我们封装了一个通用组件发布库：

```java
apply plugin: 'maven'


uploadArchives {
    repositories {
        mavenDeployer {
            // 是否快照版本
            def isSnapShot = Boolean.valueOf(MAVEN_IS_SNAPSHOT)
            def versionName = MAVEN_VERSION
            if (isSnapShot) {
                versionName += "-SNAPSHOT"
            }
            // 组件信息
            pom.groupId = MAVEN_GROUP_ID
            pom.artifactId = MAVEN_ARTIFACTID
            pom.version = versionName

            // 快照仓库路径
            snapshotRepository(url: uri(MAVEN_SNAPSHOT_URL)) {
                authentication(userName: MAVEN_USERNAME, password: MAVEN_USERNAME)
            }
            // 发布仓库路径
            repository(url: uri(MAVEN_RELEASE_URL)) {
                authentication(userName: MAVEN_USERNAME, password: MAVEN_USERNAME)
            }

            println("###################################"
                    + "\nuploadArchives = " + pom.groupId + ":" + pom.artifactId + ":" + pom.version + "." + pom.packaging
                    + "\nrepository =" + (isSnapShot ? MAVEN_SNAPSHOT_URL : MAVEN_RELEASE_URL)
                    + "\n###################################"
            )
        }
    }
}

```

然后在对应的组件下面引用：

```java
apply from:file('../maven.gradle')
```

发布的时候直接在`Gradle`面板中点击`uploadArchives`任务即可

![task面板.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a260bac42ab4075a5b9e67c2fe2cab0~tplv-k3u1fbpfcp-watermark.image?)

**经过上面几个步骤就基本完成了login组件的封装并发布，且对外提供了login组件接口
其他组件也是按照上面的逻辑进行重构**

**更多详细信息可以自己拿到[项目源代码](https://github.com/ByteYuhb/anna_music_app)查看。**
## 5.组件化重构总结

**组件化不仅是一种架构，更是一种思想，架构是可以变得，但是核心思想却是统一的，在拆分代码的时候，要注意模块的颗粒度，不是颗粒度越小就越好，模块分离的好，后期对组件改造会有很大帮助，
关于组件化的文章就讲到这里，组件化重构的项目已经上传到Github。
后面会出一期`插件化`的项目改造。敬请期待。**