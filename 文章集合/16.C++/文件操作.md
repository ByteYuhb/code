> 🔥 **Hi，我是小余。本文已收录到 [GitHub · Androider-Planet](https://github.com/ByteYuhb/Androider-Planet) 中。这里有 Android 进阶成长知识体系，关注公众号 [小余的自习室] ，在成功的路上不迷路！**

## 前言

> 内存中的数据在断电之后就会消失，如果需要**持久化数据**，则需要将数据写入到文件中

C++中使用输入流和输出流来操作文件：输入流起点和输出流的终点都可以是磁盘文件：
如：

```c++
cout<<"hello"<<endl;
```

cout是输出流的终点，可以把cout就看成是一个文件描述符，数据顺着<<流到cout这个文件中

```c++
cin>>char buf[];
```

cin是输入流的起点，可以把cin就看成是一个文件描述符，数据顺着>>从cin文件中流到buf数组中

**C++中读写文件有两种文件格式**：

- 文本格式：
  **文件信息采用ASCII码进行存储，每个字符占用一个字节**
- 二进制文件：
  **文件信息和内存中的信息一致，也就是二进制格式，一般情况下比较难看懂**。

## 1.文本文件读写
### 1.1 写文件：

- 步骤：

```c++
1.包含头文件
#include <fstream>
2.创建流对象
ofstream ofs;
3.打开文件
ofs.open("文件路径名", 打开方式);

4.写文件数据
ofs << "写入的数据";
或者
ofs.write("数据"，数据大小)

5.关闭流
ofs.close
```

- 打开方式权限：

| 打开方式    | 意义                                                         |
| ----------- | ------------------------------------------------------------ |
| iso::in     | 只读方式                                                     |
| iso::out    | 只写方式                                                     |
| ios::binary | 二进制方式写入                                               |
| ios::app    | 追加方式写文件                                               |
| ios::trunc  | 如果文件存在先删除，再创建                                   |
| ios::ate    | 可以和ios::in配合，此时定位到文件尾；如果没有ios::in相配合而只是同ios::out配合，那么将清空原文件； |

注意：

> 上面的方式可以使用 | 操作符 配合使用
> 例如：用二进制方式写文件 ios::binary | ios::out

- 写文件代码

```
#include <fstream>
void FIleTest::main() {
	//文本文件
	ofstream ofs;
	ofs.open("file.txt", ios::out);
	if (!ofs.is_open()) {
		return;
	}
	ofs<<"1234"<<"nihao"<<endl;
	ofs.close();
}
```

### 1.2 读文件
- 步骤：

```
1.包含头文件

#include <fstream>

2.创建流对象

ifstream ifs;

3.打开文件并判断文件是否打开成功

ifs.open(""文件路径".打开方式);

4.读数据

1.ifs<<buf 
2.使用getLine逐行读取
3.ifs.read函数读取

5.关闭文件

ifs.close();
```

- 读文件代码：

```
#include <fstream>
void FIleTest::main() {
	ifstream ifs("file.txt");
	if (!ifs.is_open()) {
		return;
	}
	char buf[100] = { 0 };	
	

	//方式1：
	char buf[1024] = {0};  //初始化一个全为0的数组
	while ( ifs >> buf )
	{
		cout << buf << endl;
	}
	
	//方式2：
	while()
	while (ifs.getline(buf, sizeof(buf))) {//逐行读取
		cout << buf << endl;
	}
	ifs.close();

}
```

## 2 二进制文件

以二进制的方式对文件进行读写操作:**打开方式要指定为ios:binary**
### 2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

```
函数原型：ostrean& warite( const char * buffer, int len);

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数
```

代码如下：

```
class Person {

public :
	string m_name;
	int age;
	~Person() {

	}

};
void writeFile(string filename) {
	//二进制文件
	ofstream ofs1;
	ofs1.open(filename, ios::out | ios::binary);
	if (!ofs1.is_open()) {
		return;
	}
	Person per = { "123",10 };

	ofs1.write((const char*)&per, sizeof(Person));
	ofs1.close();

}
```

### 2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

```
函数原型：istream& read(char *buffer, int len);

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数
```

代码如下：

```
void readFile(string filename) {
	ifstream ifs1(filename, ios::in);
	if (!ifs1.is_open()) {
		return;
	}
	Person per1;
	ifs1.read((char*)&per1, sizeof(Person));

	cout << per1.m_name << ":" << per1.age << endl;
	
	ifs1.close();

}

运行结果：
123:10
```

注意点：

> 对于is_open还是使用fail判断文件打开状态有什么不同：
> 一个是看文件流是否打开，说白了就是文件指针是否正常；一个是判断使用文件流过程中有没有出错，通过一些标志位来探测，二者检查的东西不一样。

[文章完整代码](https://github.com/ByteYuhb/Androider-Planet/blob/main/20221229-demo-cAndCpp/20221229-demo-cAndCpp/FIleTest.cpp)

