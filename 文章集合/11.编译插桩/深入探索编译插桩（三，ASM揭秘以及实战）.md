> ğŸ”¥ **Hiï¼Œæˆ‘æ˜¯å°ä½™ã€‚**
>
> **æœ¬æ–‡å·²æ”¶å½•åˆ° [GitHub Â· Androider-Planet](https://github.com/ByteYuhb/Androider-Planet) ä¸­ã€‚è¿™é‡Œæœ‰ Android è¿›é˜¶æˆé•¿çŸ¥è¯†ä½“ç³»ï¼Œå…³æ³¨å…¬ä¼—å· [å°ä½™çš„è‡ªä¹ å®¤] ï¼Œåœ¨æˆåŠŸçš„è·¯ä¸Šä¸è¿·è·¯ï¼**
## å‰è¨€
æœ€è¿‘åœ¨å­¦ä¹ ä¸€äº›å…³äºç¼–è¯‘æ’æ¡©æ–¹é¢çš„çŸ¥è¯†ï¼Œè¯´åˆ°ç¼–è¯‘æ’æ¡©ï¼šå¤§å®¶å¯ä»¥æƒ³åˆ°çš„å“ªäº›å…³é”®å­—ï¼š
`Gradleæ’ä»¶`ï¼Œ`ASM`ï¼Œ`AspectJ`ï¼Œ`AOP`ï¼Œ`JVMå­—èŠ‚ç `ç­‰ã€‚

å…¶ä¸­`ASMï¼ŒAspectJ`ç”¨äºå­—èŠ‚ç æ’å…¥æ“ä½œï¼Œè€Œ`Gradleæ’ä»¶`ç”¨äºåœ¨ç¼–è¯‘æœŸä¼ å…¥å­—èŠ‚ç .classæ–‡ä»¶å’Œè¾“å‡ºé‡ç¼–å†™åçš„å­—èŠ‚ç .classã€‚
è€Œ`JVMå­—èŠ‚ç `åˆ™å…³ç³»æˆ‘ä»¬å…·ä½“æ’å…¥ä»£ç å¦‚ä½•å®ç°ã€‚
`AOPåˆ™æ˜¯ä¸€ç§é¢å‘åˆ‡é¢çš„ç¼–ç¨‹æ€æƒ³`ï¼Œå¦‚ä½•ç†è§£åˆ‡é¢ï¼šçœ‹ä¸‹é¢å›¾

![é¢å‘AOP.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29f4e87ec7ce4ec5a83ce064018246f8~tplv-k3u1fbpfcp-watermark.image?)

è¿™å¹…å›¾ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é’ˆå¯¹æ‰€æœ‰æ–¹æ³•èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®åšä¸€äº›æ“ä½œï¼Œå¦‚`ç»Ÿè®¡æ–¹æ³•æ—¶å¸¸`ç­‰æ“ä½œï¼Œ`æ‰“å°æ–¹æ³•æ—¥å¿—`ã€‚
**è¿™é‡Œçš„èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®å°±æ˜¯ä¸€ç§åˆ‡æ¢ç¼–ç¨‹å®ç°ï¼Œç®€ç§°AOPã€‚**
åŒç†ï¼šå¯¹äºå¯¹è±¡å±æ€§å­—æ®µçš„è®¿é—®ä¹Ÿå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼ï¼Œå¦‚æ£€æµ‹æ‰€æœ‰å­—æ®µæ˜¯å¦å«æœ‰æŸç§ç‰¹å®šçš„æ³¨è§£ï¼Œç„¶åå¯¹è¯¥å­—æ®µåšä¸€äº›åˆ†æç»Ÿè®¡æ“ä½œã€‚

- **ASMï¼ŒAspectJå¦‚ä½•é€‰æ‹©ï¼Ÿ**

- `AspectJ`ï¼š
**ä¼˜ç‚¹å°±æ˜¯ä½¿ç”¨ç®€å•ï¼Œä½†æ˜¯å…¶åŸºäºè§„åˆ™ï¼Œåˆ‡å…¥ç‚¹ç›¸å¯¹å›ºå®šï¼Œåšå­—èŠ‚ç çš„æ“ä½œè‡ªç”±åº¦è¾ƒä½ï¼Œä¸”ä¼šç”Ÿæˆä¸€äº›é¢å¤–åŒ…è£…ä¿¡æ¯ã€‚**

- `ASM`:
**ä¼˜ç‚¹æ˜¯åŸºäºå­—èŠ‚ç çš„æ“ä½œï¼Œå¯ä»¥è¯´åªè¦å¯¹JVMå­—èŠ‚ç æŒæ¡çš„å¾ˆå¥½ï¼Œå¯ä»¥å®ç°ä»»ä½•åˆ‡é¢æ–¹é¢çš„éœ€æ±‚ã€‚
ç¼ºç‚¹å°±æ˜¯ä¸Šæ‰‹éš¾åº¦å¤§ï¼Œä¸€èˆ¬å¼€å‘è€…å¾ˆéš¾å®ç°ç¨å¾®å¤æ‚ç‚¹çš„éœ€æ±‚ï¼Œ**

> ä½†æ˜¯è¯è¯´å›æ¥ï¼Œå¤ªå¤æ‚çš„éœ€æ±‚å¤§å®¶è§‰å¾—æœ‰å¿…è¦ç”¨`AOPç¼–ç¨‹`ä¹ˆï¼Ÿ

**åŸºäºä»¥ä¸Šå‡ ç‚¹ï¼Œæœ¬ç¯‡æ–‡ç« è®²è§£å°†ç”±ASMå±•å¼€ã€‚ç¬”è€…ä¼šå…ˆè®²è§£ä¸€äº›å…³äºASMçš„åŸºæœ¬APIå’ŒåŸºæœ¬åŸç†çš„è®²è§£ï¼Œæœ€åä½¿ç”¨ä¸€ä¸ªDemoæ¥å®æˆ˜ä¸‹**

## ASMçš„ä¸¤ç§æ¨¡å‹

### å¯¹è±¡æ¨¡å‹(ASM Tree API)
ASMå¯¹è±¡æ¨¡å‹ä½¿ç”¨ä¸€ä¸ªæ ‘çŠ¶å›¾æ¥æè¿°ä¸€ä¸ªç±»ï¼š
æ¯ä¸ªèŠ‚ç‚¹åˆæœ‰å­èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹åˆæœ‰å­èŠ‚ç‚¹ï¼Œå’Œè®¾è®¡æ¨¡å¼ä¸­çš„ç»„åˆæ¨¡å¼ç±»ä¼¼

![å¯¹è±¡æ¨¡å‹.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea3541acdf974bf1b9e5dd418e26363b~tplv-k3u1fbpfcp-watermark.image?)

å¯¹è±¡æ¨¡å‹ä¼˜ç¼ºç‚¹ï¼š
**å­¦ä¹ æˆæœ¬è¾ƒä½ï¼Œä»£ç é‡å°‘ï¼Œäº‹å®œå¤„ç†ç®€å•ç±»çš„ä¿®æ”¹ï¼Œä¸é€‚åˆå¤æ‚åœºæ™¯ã€‚**

å¯¹è±¡æ¨¡å‹çš„æ“ä½œçº¬åº¦
- 1)**è·å–èŠ‚ç‚¹**ï¼šè·å–ç±»ï¼Œå­—æ®µï¼Œæ–¹æ³•èŠ‚ç‚¹ï¼Œæ³¨è§£èŠ‚ç‚¹ç­‰
- 2)**é’ˆå¯¹æ–¹æ³•èŠ‚ç‚¹çš„æ“ä½œç **ï¼šè·å–æ“ä½œç ï¼Œæ“ä½œç çš„æ›¿æ¢ï¼Œåˆ é™¤ï¼Œæ’å…¥ï¼Œè¾“å‡ºå­—èŠ‚ç 


#### 1.è·å–èŠ‚ç‚¹

##### 1.1)**è·å–æŒ‡å®šç±»èŠ‚ç‚¹**

ä½¿ç”¨å¦‚ä¸‹ä»£ç è·å–èŠ‚ç‚¹ï¼š
```java
ClassNode classNode = new ClassNode();
// 1
ClassReader classReader = new ClassReader(bytes);
// 2
classReader.accept(classNode, 0);
```
**ä½¿ç”¨ClassReaderæ¥æ”¶ä¸€ä¸ªclassè¾“å…¥å­—èŠ‚ï¼Œç„¶åä½¿ç”¨acceptæ–¹æ³•å¯ä»¥å°†classå­—èŠ‚è¾“å‡ºåˆ°classNodeä¸­ï¼Œ
è¿™æ ·å°±å°†classå­—èŠ‚è¾“å‡ºåˆ°äº†ä¸€ä¸ªClassNodeç±»èŠ‚ç‚¹ä¸­ã€‚**
ClassNodeç±»ç»“æ„ï¼š


| ç±»å‹   | åç§°                 | è¯´æ˜                                   |
| ------ | -------------------- | -------------------------------------- |
| int    | version              | classæ–‡ä»¶çš„majorç‰ˆæœ¬ï¼ˆç¼–è¯‘çš„javaç‰ˆæœ¬ï¼‰ |
| int    | access               | è®¿é—®çº§                                 |
| String | name                 | ç±»åï¼Œé‡‡ç”¨å…¨åœ°å€ï¼Œå¦‚java/lang/String   |
| String | signature            | ç­¾åï¼Œé€šå¸¸æ˜¯null                       |
| String | superName            | çˆ¶ç±»ç±»åï¼Œé‡‡ç”¨å…¨åœ°å€                   |
| List   | interfaces           | å®ç°çš„æ¥å£,é‡‡ç”¨å…¨åœ°å€                  |
| String | sourceFile           | æºæ–‡ä»¶ï¼Œå¯èƒ½ä¸ºnull                     |
| String | sourceDebug          | debugæºï¼Œå¯èƒ½ä¸ºnull                    |
| String | outerClass           | å¤–éƒ¨ç±»                                 |
| String | outerMethod          | å¤–éƒ¨æ–¹æ³•                               |
| String | outerMethodDesc      | å¤–éƒ¨æ–¹æ³•æè¿°ï¼ˆåŒ…æ‹¬æ–¹æ³•å‚æ•°å’Œè¿”å›å€¼ï¼‰   |
| List   | visibleAnnotations   | å¯è§çš„æ³¨è§£                             |
| List   | invisibleAnnotations | ä¸å¯è§çš„æ³¨è§£                           |
| List   | attrs                | ç±»çš„Attribute                          |
| List   | innerClasses         | ç±»çš„å†…éƒ¨ç±»åˆ—è¡¨                         |
| List   | fields               | ç±»çš„å­—æ®µåˆ—è¡¨                           |
| List   | methods              | ç±»çš„æ–¹æ³•åˆ—è¡¨                           |

##### 1.2)**è·å–æŒ‡å®šå­—æ®µçš„èŠ‚ç‚¹**

```java
for(FieldNode fieldNode : (List)classNode.fields) {
    // 1
    if(fieldNode.name.equals("password"))  {
        // 2
        fieldNode.access = Opcodes.ACC_PUBLIC;
    }
}
```
è¿™é‡Œå°†classNodeä¸­çš„ä¸€ä¸ªå­—æ®µåä¸ºpasswordèŠ‚ç‚¹çš„å­—æ®µæƒé™æ›´æ”¹ä¸ºäº†public

ä¹Ÿå¯ä»¥ä¸ºclassNodeæ·»åŠ ä¸€ä¸ªå­—æ®µï¼š

```java
FieldNode field = new FieldNode(Opcodes.ACC_PUBLIC,"yuhb","B",null,null);
classNode.fields.add(field);
```

è¿™æ ·å°±ä¸ºå¯ä»¥ä¸ºæ‰€æœ‰æˆ–è€…ç‰¹å®šçš„ç±»æ·»åŠ ä¸€ä¸ªå­—æ®µï¼š
**public byte yuhb;**

å­—æ®µèŠ‚ç‚¹ï¼š

| ç±»å‹   | åç§°                 | è¯´æ˜                                                         |
| ------ | -------------------- | ------------------------------------------------------------ |
| int    | access               | è®¿é—®çº§                                                       |
| String | name                 | å­—æ®µå                                                       |
| String | signature            | ç­¾åï¼Œé€šå¸¸æ˜¯ null                                            |
| String | desc                 | ç±»å‹æè¿°ï¼Œä¾‹å¦‚ Ljava/lang/Stringã€Dï¼ˆdoubleï¼‰ã€Fï¼ˆfloatï¼‰Objectvalueåˆå§‹å€¼ï¼Œé€šå¸¸ä¸º null |
| List   | visibleAnnotations   | å¯è§çš„æ³¨è§£                                                   |
| List   | invisibleAnnotations | ä¸å¯è§çš„æ³¨è§£                                                 |
| List   | attrs                | å­—æ®µçš„ Attribute                                             |

##### 1.3)**è·å–æŒ‡å®šæ–¹æ³•çš„èŠ‚ç‚¹**

```java
for(MethodNode methodNode : (List)classNode.methods) {
    // 1ã€åˆ¤æ–­æ–¹æ³•åæ˜¯å¦åŒ¹é…ç›®æ ‡æ–¹æ³•
    if(methodNode.name.equals("getName")) {
        // 2ã€è¿›è¡Œæ“ä½œ
    }
}
```
**methods åŒ fields ä¸€æ ·ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª ArrayListï¼Œé€šè¿‡éå†å¹¶åˆ¤æ–­æ–¹æ³•åçš„æ–¹å¼å³å¯åŒ¹é…åˆ°ç›®æ ‡æ–¹æ³•ã€‚**

å¯¹äºä¸€ä¸ªæ–¹æ³•èŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒåŒ…å«æœ‰å¦‚ä¸‹ä¿¡æ¯ï¼š

æ–¹æ³•èŠ‚ç‚¹åŒ…å«çš„ä¿¡æ¯
| ç±»å‹     | åç§°                          | è¯´æ˜                               |
| -------- | ----------------------------- | ---------------------------------- |
| int      | access                        | è®¿é—®çº§                             |
| String   | name                          | æ–¹æ³•å                             |
| String   | desc                          | æ–¹æ³•æè¿°ï¼Œå…¶åŒ…å«æ–¹æ³•çš„è¿”å›å€¼å’Œå‚æ•° |
| String   | signature                     | ç­¾åï¼Œé€šå¸¸æ˜¯null                   |
| List     | exceptions                    | å¯èƒ½è¿”å›çš„å¼‚å¸¸åˆ—è¡¨                 |
| List     | visibleAnnotations            | å¯è§çš„æ³¨è§£åˆ—è¡¨                     |
| List     | invisibleAnnotations          | ä¸å¯è§çš„æ³¨è§£åˆ—è¡¨                   |
| List     | attrs                         | æ–¹æ³•çš„Attributeåˆ—è¡¨                |
| Object   | annotation                    | Defaulté»˜è®¤çš„æ³¨è§£                  |
| List     | visibleParameterAnnotations   | å¯è§çš„å‚æ•°æ³¨è§£                     |
| List     | invisibleParameterAnnotations | ä¸å¯è§çš„å‚æ•°æ³¨è§£åˆ—è¡¨               |
| InsnList | instructions                  | æ“ä½œç åˆ—è¡¨                         |
| List     | tryCatchBlock                 | stry-catchå—åˆ—è¡¨                   |
| int      | maxStack                      | æœ€å¤§æ“ä½œæ ˆçš„æ·±åº¦                   |
| int      | maxLocals                     | æœ€å¤§å±€éƒ¨å˜é‡åŒºçš„å¤§å°               |
| List     | localVariables                | æœ¬åœ°ï¼ˆå±€éƒ¨ï¼‰å˜é‡èŠ‚ç‚¹åˆ—è¡¨           |

**è¿™é‡Œæˆ‘é—®ä¸‹å¤§å®¶æ—¢ç„¶æ˜¯æ–¹æ³•èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ–¹æ³•å†…éƒ¨ä»£ç å­˜å‚¨åœ¨å“ªé‡Œé¢å‘¢ï¼Ÿ**
> å‰é¢æˆ‘ä»¬è®²è§£Classæ–‡ä»¶ç»“æ„çš„æ—¶å€™ï¼ŒçŸ¥é“åœ¨Classæ–‡ä»¶çš„æ–¹æ³•è¡¨ä¸­çš„å±æ€§åˆ—è¡¨ä¼šæœ‰ä¸€ä¸ªCodeçš„å±æ€§ï¼Œæˆ‘ä»¬çš„ä»£ç å°±æ˜¯å­˜å‚¨åœ¨Codeå±æ€§åˆ—è¡¨ä¸­ã€‚
> è¿™é‡Œæˆ‘ä»¬çš„ASMä¹Ÿæ˜¯ä¸€æ ·ï¼Œå…¶å°†Codeå±æ€§ä¸­çš„æ–¹æ³•ä»£ç å­˜å‚¨åˆ°äº†æ–¹æ³•èŠ‚ç‚¹ä¸­çš„`instructions`åˆ—è¡¨ä¸­ã€‚è¿™ä¸ªåˆ—è¡¨å°±æ˜¯ASMæ“æ§å­—èŠ‚ç çš„åœ°æ–¹


ä¸‹é¢æˆ‘ä»¬æ¥è®²è§£ä¸‹æ“ä½œç ã€‚
##### 1.4)**æ“æ§æ“ä½œç **

æ–¹æ³•èŠ‚ç‚¹ä¸­`instructionsåˆ—è¡¨`æ˜¯ç”¨äºå­˜å‚¨æ“ä½œç çš„åœ°æ–¹ï¼Œå…¶ä¸­ **æ¯ä¸€ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€è¡Œæ“ä½œç ã€‚**	

**ASM å°†ä¸€è¡Œå­—èŠ‚ç å°è£…ä¸ºä¸€ä¸ª xxxInsnNodeï¼ˆInsn è¡¨ç¤ºçš„æ˜¯ Instruction çš„ç¼©å†™ï¼Œå³æŒ‡ä»¤/æ“ä½œç ï¼‰ï¼Œä¾‹å¦‚ ALOAD/ARestore æŒ‡ä»¤è¢«å°è£…å…¥å˜é‡æ“ä½œç èŠ‚ç‚¹  VarInsnNodeï¼ŒINVOKEVIRTUAL æŒ‡ä»¤åˆ™ä¼šè¢«å°å…¥æ–¹æ³•æ“ä½œç èŠ‚ç‚¹ MethodInsnNode ä¹‹ä¸­ã€‚**

æ“ä½œç ä¸­çš„`xxxInsnNode`éƒ½ç»§æ‰¿è‡ª`AbstractInsnNode`ã€‚ä¸‹é¢åˆ—è¡¨åˆ—å‡ºå…¶æ‰€æœ‰æ´¾ç”Ÿç±»çš„æƒ…å†µ

**æ‰€æœ‰çš„æŒ‡ä»¤ç èŠ‚ç‚¹è¯´æ˜**
| åç§°                      | è¯´æ˜                                                         | å‚æ•°                                                         |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| FieldInsnNode             | ç”¨äº GETFIELD å’Œ PUTFIELD ä¹‹ç±»çš„å­—æ®µæ“ä½œçš„å­—èŠ‚ç              | String owner å­—æ®µæ‰€åœ¨çš„ç±»String name å­—æ®µçš„åç§°String desc å­—æ®µçš„ç±»å‹ |
| FrameNode                 | æ ˆæ˜ å°„å¸§çš„å¯¹åº”çš„å¸§èŠ‚ç‚¹                                       | å¾…è¡¥å……                                                       |
| IincInsnNode              | ç”¨äº IINC å˜é‡è‡ªåŠ æ“ä½œçš„å­—èŠ‚ç                                | int varï¼šç›®æ ‡å±€éƒ¨å˜é‡çš„ä½ç½®int incrï¼š è¦å¢åŠ çš„æ•°             |
| InsnNode                  | ä¸€åˆ‡æ— å‚æ•°å€¼æ“ä½œçš„å­—èŠ‚ç ï¼Œä¾‹å¦‚ ALOAD_0ï¼ŒDUPï¼ˆæ³¨æ„ä¸åŒ…å« POPï¼‰ | æ—                                                            |
| IntInsnNode               | ç”¨äº BIPUSHã€SIPUSH å’Œ NEWARRAY è¿™ä¸‰ä¸ªç›´æ¥æ“ä½œæ•´æ•°çš„æ“ä½œ     | int operandï¼šæ“ä½œçš„æ•´æ•°å€¼                                    |
| InvokeDynamicInsnNode     | ç”¨äº Java7 æ–°å¢çš„ INVOKEDYNAMIC æ“ä½œçš„å­—èŠ‚ç                  | String nameï¼šæ–¹æ³•åç§°String descï¼šæ–¹æ³•æè¿°Handle bsmï¼šå¥æŸ„Object bsmArgsï¼šå‚æ•°å¸¸é‡ |
| JumpInsnNode              | ç”¨äº IFEQ æˆ– GOTO ç­‰è·³è½¬æ“ä½œå­—èŠ‚ç                            | LabelNode lableï¼šç›®æ ‡lable                                   |
| LabelNode                 | ä¸€ä¸ªç”¨äºè¡¨ç¤ºè·³è½¬ç‚¹çš„ Label èŠ‚ç‚¹                              | æ—                                                            |
| LdcInsnNode               | ä½¿ç”¨ LDC åŠ è½½å¸¸é‡æ± ä¸­å¼•ç”¨å€¼å¹¶è¿›è¡Œæ’å…¥çš„å­—èŠ‚ç                 | Object cstï¼šå¼•ç”¨å€¼                                           |
| LineNumberNode            | è¡¨ç¤ºè¡Œå·çš„èŠ‚ç‚¹                                               | int lineï¼šè¡Œå·LabelNode startï¼šå¯¹åº”çš„ç¬¬ä¸€ä¸ª                  |
| LabelLookupSwitchInsnNode | ç”¨äºå®ç° LOOKUPSWITCH æ“ä½œçš„å­—èŠ‚ç                            | LabelNode dfltï¼šdefault å—å¯¹åº”çš„ LableList keys é”®åˆ—è¡¨List labelsï¼šå¯¹åº”çš„ Label èŠ‚ç‚¹åˆ—è¡¨ |
| MethodInsnNode            | ç”¨äº INVOKEVIRTUAL ç­‰ä¼ ç»Ÿæ–¹æ³•è°ƒç”¨æ“ä½œçš„å­—èŠ‚ç ï¼Œ              | ä¸é€‚ç”¨äº Java7 æ–°å¢çš„ INVOKEDYNAMICString owner ï¼šæ–¹æ³•æ‰€åœ¨çš„ç±»String name ï¼šæ–¹æ³•åç§°String descï¼šæ–¹æ³•æè¿° |
| MultiANewArrayInsnNode    | ç”¨äº MULTIANEWARRAY æ“ä½œçš„å­—èŠ‚ç                              | String descï¼šç±»å‹æè¿°int dimsï¼šç»´æ•°                          |
| TableSwitchInsnNode       | ç”¨äºå®ç° TABLESWITCH æ“ä½œçš„å­—èŠ‚ç                             | int minï¼šé”®çš„æœ€å°å€¼int maxï¼šé”®çš„æœ€å¤§å€¼LabelNode dfltï¼šdefault å—å¯¹åº”çš„ LableList labelsï¼šå¯¹åº”çš„ Label èŠ‚ç‚¹åˆ—è¡¨ |
| TypeInsnNode              | ç”¨äºå®ç° NEWã€ANEWARRAY å’Œ CHECKCAST ç­‰ç±»å‹ç›¸å…³æ“ä½œçš„å­—èŠ‚ç   | String descï¼šç±»å‹VarInsnNodeç”¨äºå®ç° ALOADã€ASTORE ç­‰å±€éƒ¨å˜é‡æ“ä½œçš„å­—èŠ‚ç int varï¼šå±€éƒ¨å˜é‡ |

ä¸‹é¢æ¥çœ‹å¸¸è§çš„å‡ ç§å¯¹æ“ä½œç çš„å¤„ç†ã€‚

- 1.**éå†å½“å‰æ–¹æ³•ä¸­çš„æ‰€æœ‰æ“ä½œç **ï¼š
ä½¿ç”¨ä¸‹é¢æ–¹æ³•éå†instructionsï¼š

```java
ClassNode classNode = new ClassNode();
ClassReader reader = new ClassReader(is);
reader.accept(classNode,0);
List<MethodNode> methodNodeList = classNode.methods;
for(MethodNode methodNode:methodNodeList){
	for(AbstractInsnNode node:methodNode.instructions.toArray()){
		Log.d("TAG",node.toString());
	}
}
```
æ‰“å°ç»“æœï¼šå¯ä»¥çœ‹åˆ°è¿™é‡Œå‡ºç°äº†å¾ˆå¤šæ“ä½œç ï¼Œæ¯ä¸ªæ“ä½œç éƒ½ä»£è¡¨äº†å½“å‰æ–¹æ³•çš„æŸä¸€è¡Œä»£ç 

```java
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@17520e0b
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@2c974016
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@3eb19446
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@4b4bf90c
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@3854f881
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@2ed5986d
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@1c742a55
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@8e3234e
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@17ec5223
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@1578b643
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@2863003b
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@390bbf2a
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@4c038f62
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@1c99e20f
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@2c4b5b7f
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@48dd5333
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@18f5add5
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@4bafad5e
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@3dc997f7
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@1faf0fb6
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@2a018293
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@1cf20fd0
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@6d754596
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@a402531
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@6c0f4d3d
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@5996d7f7
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@60b5e341
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@6b79dd7e
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@7d090389
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@124f5ab0
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@5d2f0c53
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@7898b8a5
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@4d38e974
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@254ab0b9
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@226dd7
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@3dc2a0e6
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@37bb8d63
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@47042c55
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@545badb7
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@7c36e24a
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@178da83a
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@710d481a
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@78327599
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@33ddfc67
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@496b4e5e
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@52bd92f1
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@3948ab82
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@65aa4608
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@76a0ed5d
[DEBUG][TAG]org.objectweb.asm.tree.LineNumberNode@48b4d362
[DEBUG][TAG]org.objectweb.asm.tree.VarInsnNode@345c754d
[DEBUG][TAG]org.objectweb.asm.tree.MethodInsnNode@3f1ffc8
[DEBUG][TAG]org.objectweb.asm.tree.InsnNode@724a20ee
[DEBUG][TAG]org.objectweb.asm.tree.LabelNode@1c8bd206

```
- 2)**è·å–æ“ä½œç çš„ä½ç½®**

ç”¨ä¸‹é¢æŒ‡ä»¤è¿‡æ»¤äº†æ‰€æœ‰æ“ä½œç ä¸ºALOADçš„æŒ‡ä»¤ï¼š

```java
List<MethodNode> methodNodeList = classNode.methods;
for(MethodNode methodNode:methodNodeList){
	for(AbstractInsnNode node:methodNode.instructions.toArray()){
		if(node.getOpcode()==Opcodes.ALOAD){
			VarInsnNode varNode = (VarInsnNode) node;
			Log.d("TAG",varNode.toString()+"var:"+varNode.var);
		}
	}
}
```

- 3)**æ›¿æ¢æ“ä½œ**

ä½¿ç”¨ä¸‹é¢æ“ä½œå°†å½“å‰VarInsnNodeæ›¿æ¢ä¸ºæ–°çš„VarInsnNodeä¸”æ“ä½œæ•°+1

```java
List<MethodNode> methodNodeList = classNode.methods;
for(MethodNode methodNode:methodNodeList){
	for(AbstractInsnNode node:methodNode.instructions.toArray()){
		if(node.getOpcode()==Opcodes.ALOAD){
			VarInsnNode varNode = (VarInsnNode) node;
			Log.d("TAG",varNode.toString()+"var:"+varNode.var);
			methodNode
			methodNode.instructions.set(node,new VarInsnNode(Opcodes.ALOAD,varNode.var+1));
			
		}
	}
}

```

- 4)**æ’å…¥æ“ä½œ**

`InsnList` ä¸»è¦æä¾›äº† **å››ç±»** æ–¹æ³•ç”¨äºæ’å…¥å­—èŠ‚ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
InsnListå†…éƒ¨ä½¿ç”¨çš„æ˜¯é“¾è¡¨çš„æ•°æ®ç»“æ„å¯¹å­—èŠ‚èŠ‚ç‚¹è¿›è¡Œå­˜å‚¨

1ï¼‰ã€`add(AbstractInsnNode insn)`ï¼š å°†ä¸€ä¸ªæ“ä½œç æ·»åŠ åˆ° InsnList çš„æœ«å°¾ã€‚

2ï¼‰ã€`insert(AbstractInsnNode insn)`ï¼š å°†ä¸€ä¸ªæ“ä½œç æ’å…¥åˆ°è¿™ä¸ª InsnList çš„å¼€å¤´ã€‚

3ï¼‰ã€`insert(AbstractInsnNode insnNodeï¼ŒAbstractInsnNode insn)`ï¼š å°†ä¸€ä¸ªæ“ä½œç æ’å…¥åˆ°å¦ä¸€ä¸ªæ“ä½œç çš„ä¸‹é¢ã€‚

4ï¼‰ã€`insertBefore(AbstractInsnNode insnNodeï¼ŒAbstractInsnNode insn)` å°†ä¸€ä¸ªæ“ä½œç æ’å…¥åˆ°å¦ä¸€ä¸ªæ“ä½œç çš„ä¸Šé¢

```java
//æ·»åŠ åˆ°instructionsçš„æœ«å°¾
methodNode.instructions.add(new VarInsnNode(Opcodes.ILOAD,2));
//æ’å…¥åˆ°instructionsçš„å¼€å¤´
methodNode.instructions.insert(new VarInsnNode(Opcodes.ILOAD,0) );
//æ’å…¥åˆ°instructionsçš„nodeèŠ‚ç‚¹åé¢
methodNode.instructions.insert(node,new VarInsnNode(Opcodes.ILOAD,0));
//æ’å…¥åˆ°instructionsçš„nodeèŠ‚ç‚¹å‰é¢
methodNode.instructions.insertBefore(node,new VarInsnNode(Opcodes.ILOAD,0));
```

- 5)**åˆ é™¤æ“ä½œ**

methodNode.instructions.remove(node);
ç›´æ¥è°ƒç”¨removeæ–¹æ³•ç§»é™¤èŠ‚ç‚¹ã€‚

### ASMäº‹ä»¶æ¨¡å‹ï¼ˆASM Core APIï¼‰

**é¦–å…ˆè¦äº†è§£ASMçš„å¯¹è±¡æ¨¡å‹æ˜¯åœ¨äº‹ä»¶æ¨¡å‹çš„åŸºç¡€ä¸Šå°è£…è€Œæˆï¼Œæ‰€ä»¥äº‹ä»¶æ¨¡å‹æ›´åå‘åº•å±‚ï¼Œä¸Šæ‰‹éš¾åº¦è‚¯å®šä¹Ÿæ›´å¤§**

äº‹ä»¶æ¨¡å‹é‡‡ç”¨çš„æ˜¯`è®¿é—®è€…æ¨¡å¼`å®ç°ï¼š
è®¿é—®è€…æ¨¡å¼ä¸»è¦ç”¨æ¥è§£å†³ï¼š
> æ¯”å¦‚å½“å‰æœ‰Nä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ å¯¹åº”ä¸åŒçš„è®¿é—®è€…æœ‰ä¸åŒçš„å¤„ç†æ–¹æ³•ï¼Œäºæ˜¯å°†æ‰€æœ‰å…ƒç´ çš„å¤„ç†æ–¹æ³•æŠ½è±¡ä¸ºä¸€ä¸ªæ¥å£ï¼Œ
> å¤–éƒ¨è®¿é—®è€…å®ç°è¿™ä¸ªæ¥å£ï¼Œç„¶åä¼ å…¥å…ƒç´ å¤„ç†çš„æ ¸å¿ƒç±»ä¸­ï¼Œå†…éƒ¨å…ƒç´ éœ€è¦å¤„ç†å°±è°ƒç”¨ä¼ å…¥çš„è®¿é—®è€…çš„æ–¹æ³•å³å¯ã€‚

è¦ç†è§£ ASM çš„äº‹ä»¶æ¨¡å‹ï¼Œæˆ‘ä»¬å°±éœ€è¦å¯¹å…¶ä¸­çš„ ä¸¤ä¸ªé‡è¦æˆå‘˜çš„å·¥ä½œåŸç† æœ‰è¾ƒæ·±çš„äº†è§£ã€‚å®ƒä»¬ä¾¿æ˜¯ **ç±»è®¿é—®è€… ClassVisitor ä¸ ç±»è¯»å–ï¼ˆè§£æï¼‰è€… ClassReaderã€‚**

ä»å­—èŠ‚ç çš„è§†è§’ä¸­ï¼Œä¸€ä¸ª Java ç±»ç”±å¾ˆå¤šç»„ä»¶å‡èšè€Œæˆï¼Œè€Œè¿™ä¹‹ä¸­ä¾¿åŒ…æ‹¬è¶…ç±»ã€æ¥å£ã€å±æ€§ã€åŸŸå’Œæ–¹æ³•ç­‰ç­‰ã€‚å½“æˆ‘ä»¬åœ¨ä½¿ç”¨ ASM è¿›è¡Œæ“æ§æ—¶ï¼Œå¯ä»¥å°†å®ƒä»¬è§†ä¸ºä¸€ä¸ªä¸ªä¸ä¹‹å¯¹åº”çš„äº‹ä»¶ã€‚å› æ­¤ ASM æä¾›äº†ä¸€ä¸ª ç±»è®¿é—®è€… ClassVisitorï¼Œä»¥é€šè¿‡å®ƒæ¥è®¿é—®å½“å‰ç±»çš„å„ä¸ªç»„ä»¶ï¼Œå½“è§£æå™¨ ClassReader ä¾æ¬¡é‡åˆ°ä¸Šè¿°çš„å„ä¸ªç»„ä»¶æ—¶ï¼ŒClassVisitor ä¸Šå¯¹åº”çš„ visitor äº‹ä»¶å¤„ç†å™¨æ–¹æ³•å‡ä¼šè¢«ä¸€ä¸€è°ƒç”¨ã€‚

ä¸ç±»ç›¸ä¼¼ï¼Œæ–¹æ³•ä¹Ÿæ˜¯ç”±å¤šä¸ªç»„ä»¶å‡èšè€Œæˆçš„ï¼Œå…¶å¯¹åº”ç€æ–¹æ³•å±æ€§ã€æ³¨è§£åŠç¼–è¯‘åçš„ä»£ç ï¼ˆClass å­—èŠ‚ç ï¼‰ã€‚ASM çš„ MethodVisitor æä¾›äº†ä¸€ç§ hookï¼ˆé’©å­ï¼‰æœºåˆ¶ï¼Œä»¥ä¾¿èƒ½å¤Ÿè®¿é—®æ–¹æ³•ä¸­çš„æ¯ä¸€ä¸ªæ“ä½œç ï¼Œè¿™æ ·æˆ‘ä»¬ä¾¿èƒ½å¤Ÿå¯¹å­—èŠ‚ç æ–‡ä»¶è¿›è¡Œç»†ç²’åº¦åœ°ä¿®æ”¹ã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬ä¾¿æ¥ä¸€ä¸€åˆ†æä¸‹å®ƒä»¬ã€‚

#### 1.ClassVisitor
æˆ‘ä»¬åœ¨ä½¿ç”¨ASMå¤„ç†å­—èŠ‚ç æ“ä½œçš„æ—¶å€™ï¼Œé€šå¸¸ä¼šæœ‰ä¸‹é¢æ¨¡æ¿æ–¹å¼ï¼š

```java
InputStream is = new FileInputStream(classFile);
// 1
ClassReader classReader = new ClassReader(is);
// 2
ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
// 3
ClassVisitor classVisitor = new TraceClassAdapter(Opcodes.ASM5, classWriter);
// 4
classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);

```

- **æ­¥éª¤1**ï¼šå°†æ–‡ä»¶è¾“å…¥æµä¼ é€’ç»™ClassReaderï¼ŒåŒ…è£¹ä½FileInputStream
- **æ­¥éª¤2**ï¼šåˆ›å»ºä¸€ä¸ªClassWriterï¼Œå…¶å‚æ•° COMPUTE_MAXS çš„ä½œç”¨æ˜¯å°†è‡ªåŠ¨è®¡ç®—æœ¬åœ°å˜é‡è¡¨æœ€å¤§å€¼å’Œæ“ä½œæ•°æ ˆæœ€å¤§å€¼çš„ä»»åŠ¡æ‰˜ä»˜ç»™äº†ASM
- **æ­¥éª¤3**ï¼šå°†classWriterä¼ é€’ç»™TraceClassAdapterå¯¹è±¡ï¼ŒåŒ…è£¹ä½classWriterå¯¹è±¡ï¼Œå†…éƒ¨è°ƒç”¨å…¶å®è¿˜æ˜¯é€šè¿‡classWriterå®ç°
- **æ­¥éª¤4**ï¼šè°ƒç”¨acceptå°†classVisitorä¼ é€’ç»™classReaderï¼Œè¿™é‡Œæœ‰ä¸ªEXPAND_FRAMESå‚æ•°ï¼Œæ—¨åœ¨è¯´æ˜åœ¨è¯»å– class çš„æ—¶å€™éœ€è¦åŒæ—¶å±•å¼€æ ˆæ˜ å°„å¸§ï¼ˆStackMap Frameï¼‰ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦ä½¿ç”¨è‡ªå®šä¹‰çš„ MethodVisitor å»ä¿®æ”¹æ–¹æ³•ä¸­çš„æŒ‡ä»¤æ—¶å¿…é¡»è¦æŒ‡å®šè¿™ä¸ªå‚æ•°ï¼Œã€‚



#### 2.ClassReader
å‰é¢åˆ†æäº†ï¼Œæˆ‘ä»¬æ¨¡æ¿æµç¨‹æœ€ç»ˆä¼šè°ƒç”¨ClassReaderçš„acceptæ–¹æ³•
æˆ‘ä»¬è¿›å…¥è¿™ä¸ªæ–¹æ³•çœ‹çœ‹ï¼š

```java
/**
 * Makes the given visitor visit the Java class of this {@link ClassReader}
 * . This class is the one specified in the constructor (see
 * {@link #ClassReader(byte[]) ClassReader}).
 * 
 * @param classVisitor
 *            the visitor that must visit this class.
 * @param flags
 *            option flags that can be used to modify the default behavior
 *            of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}
 *            , {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
 */
public void accept(final ClassVisitor classVisitor, final int flags) {
    accept(classVisitor, new Attribute[0], flags);
}
```


åœ¨ accept æ–¹æ³•ä¸­åˆç»§ç»­è°ƒç”¨äº† classReader çš„å¦ä¸€ä¸ª accept é‡è½½æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
public void accept(final ClassVisitor classVisitor,
        final Attribute[] attrs, final int flags) {
    int u = header; // current offset in the class file
    char[] c = new char[maxStringLength]; // buffer used to read strings

    Context context = new Context();
    context.attrs = attrs;
    context.flags = flags;
    context.buffer = c;
    
    // 1ã€è¯»å–ç±»çš„æè¿°ä¿¡æ¯ï¼Œä¾‹å¦‚ accessã€name ç­‰ç­‰
    int access = readUnsignedShort(u);
    String name = readClass(u + 2, c);
    String superClass = readClass(u + 4, c);
    String[] interfaces = new String[readUnsignedShort(u + 6)];
    u += 8;
    for (int i = 0; i < interfaces.length; ++i) {
        interfaces[i] = readClass(u, c);
        u += 2;
    }
    
    // 2ã€è¯»å–ç±»çš„å±æ€§ä¿¡æ¯ï¼Œä¾‹å¦‚ç­¾å signatureã€sourceFile ç­‰ç­‰ã€‚
    String signature = null;
    String sourceFile = null;
    String sourceDebug = null;
    String enclosingOwner = null;
    String enclosingName = null;
    String enclosingDesc = null;
    int anns = 0;
    int ianns = 0;
    int tanns = 0;
    int itanns = 0;
    int innerClasses = 0;
    Attribute attributes = null;
    
    u = getAttributes();
    for (int i = readUnsignedShort(u); i > 0; --i) {
        String attrName = readUTF8(u + 2, c);
        // tests are sorted in decreasing frequency order
        // (based on frequencies observed on typical classes)
        if ("SourceFile".equals(attrName)) {
            sourceFile = readUTF8(u + 8, c);
        } else if ("InnerClasses".equals(attrName)) {
            innerClasses = u + 8;
        } else if ("EnclosingMethod".equals(attrName)) {
            enclosingOwner = readClass(u + 8, c);
            int item = readUnsignedShort(u + 10);
            if (item != 0) {
                enclosingName = readUTF8(items[item], c);
                enclosingDesc = readUTF8(items[item] + 2, c);
            }
        } else if (SIGNATURES && "Signature".equals(attrName)) {
            signature = readUTF8(u + 8, c);
        } else if (ANNOTATIONS
                && "RuntimeVisibleAnnotations".equals(attrName)) {
            anns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeVisibleTypeAnnotations".equals(attrName)) {
            tanns = u + 8;
        } else if ("Deprecated".equals(attrName)) {
            access |= Opcodes.ACC_DEPRECATED;
        } else if ("Synthetic".equals(attrName)) {
            access |= Opcodes.ACC_SYNTHETIC
                    | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
        } else if ("SourceDebugExtension".equals(attrName)) {
            int len = readInt(u + 4);
            sourceDebug = readUTF(u + 8, len, new char[len]);
        } else if (ANNOTATIONS
                && "RuntimeInvisibleAnnotations".equals(attrName)) {
            ianns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleTypeAnnotations".equals(attrName)) {
            itanns = u + 8;
        } else if ("BootstrapMethods".equals(attrName)) {
            int[] bootstrapMethods = new int[readUnsignedShort(u + 8)];
            for (int j = 0, v = u + 10; j < bootstrapMethods.length; j++) {
                bootstrapMethods[j] = v;
                v += 2 + readUnsignedShort(v + 2) << 1;
            }
            context.bootstrapMethods = bootstrapMethods;
        } else {
            Attribute attr = readAttribute(attrs, attrName, u + 8,
                    readInt(u + 4), c, -1, null);
            if (attr != null) {
                attr.next = attributes;
                attributes = attr;
            }
        }
        u += 6 + readInt(u + 4);
    }
    
    // 3ã€è®¿é—®ç±»çš„æè¿°ä¿¡æ¯
    classVisitor.visit(readInt(items[1] - 7), access, name, signature,
            superClass, interfaces);
    
    // 4ã€è®¿é—®æºç å’Œ debug ä¿¡æ¯
    if ((flags & SKIP_DEBUG) == 0
            && (sourceFile != null || sourceDebug != null)) {
        classVisitor.visitSource(sourceFile, sourceDebug);
    }
    
    // 5ã€è®¿é—®å¤–éƒ¨ç±»
    if (enclosingOwner != null) {
        classVisitor.visitOuterClass(enclosingOwner, enclosingName,
                enclosingDesc);
    }
    
    // 6ã€è®¿é—®ç±»æ³¨è§£å’Œç±»å‹æ³¨è§£
    if (ANNOTATIONS && anns != 0) {
        for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    classVisitor.visitAnnotation(readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && ianns != 0) {
        for (int i = readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    classVisitor.visitAnnotation(readUTF8(v, c), false));
        }
    }
    if (ANNOTATIONS && tanns != 0) {
        for (int i = readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    classVisitor.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && itanns != 0) {
        for (int i = readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    classVisitor.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), false));
        }
    }
    
    // 7ã€è®¿é—®ç±»çš„å±æ€§
    while (attributes != null) {
        Attribute attr = attributes.next;
        attributes.next = null;
        classVisitor.visitAttribute(attributes);
        attributes = attr;
    }
    
    // 8ã€è®¿é—®å†…éƒ¨ç±»
    if (innerClasses != 0) {
        int v = innerClasses + 2;
        for (int i = readUnsignedShort(innerClasses); i > 0; --i) {
            classVisitor.visitInnerClass(readClass(v, c),
                    readClass(v + 2, c), readUTF8(v + 4, c),
                    readUnsignedShort(v + 6));
            v += 8;
        }
    }
    
    // 9ã€è®¿é—®å­—æ®µå’Œæ–¹æ³•
    u = header + 10 + 2 * interfaces.length;
    for (int i = readUnsignedShort(u - 2); i > 0; --i) {
        u = readField(classVisitor, context, u);
    }
    u += 2;
    for (int i = readUnsignedShort(u - 2); i > 0; --i) {
        u = readMethod(classVisitor, context, u);
    }
    
    // è®¿é—®å½“å‰ç±»ç»“æŸæ—¶è°ƒç”¨
    classVisitor.visitEnd();
}
```


**é¦–å…ˆï¼Œåœ¨ classReader å®ä¾‹çš„ accept æ–¹æ³•ä¸­çš„

æ³¨é‡Š1å’Œæ³¨é‡Š2å¤„ï¼Œæˆ‘ä»¬ä¼š å…ˆå¼€å§‹è¿›è¡Œç±»ç›¸å…³çš„å­—èŠ‚ç è§£æçš„å·¥ä½œï¼šè¯»**å–äº†ç±»çš„æè¿°å’Œå±æ€§ä¿¡æ¯**ã€‚æ¥ç€ï¼Œ

åœ¨æ³¨é‡Š3 ~ æ³¨é‡Š8å¤„ï¼Œæˆ‘ä»¬**è°ƒç”¨äº† classVisitor ä¸€ç³»åˆ—çš„ visitxxx æ–¹æ³•è®¿é—® classReader è§£æå®Œå­—èŠ‚ç åä¿å­˜åœ¨å†…å­˜çš„ä¿¡æ¯**ã€‚ç„¶åï¼Œ

åœ¨æ³¨é‡Š9å¤„ï¼Œåˆ†åˆ«è°ƒç”¨äº† **readField æ–¹æ³•å’Œ readMethod** æ–¹æ³•å»è®¿é—®ç±»ä¸­çš„æ–¹æ³•å’Œå­—æ®µã€‚æœ€åï¼Œè°ƒç”¨ classVisitor çš„ visitEnd æ ‡è¯†å·²è®¿é—®ç»“æŸã€‚

- 1.**è®¿é—®å­—æ®µ**

readField

```java
/**
 * Reads a field and makes the given visitor visit it.
 * 
 * @param classVisitor
 *            the visitor that must visit the field.
 * @param context
 *            information about the class being parsed.
 * @param u
 *            the start offset of the field in the class file.
 * @return the offset of the first byte following the field in the class.
 */
private int readField(final ClassVisitor classVisitor,
        final Context context, int u) {
    // 1ã€è¯»å–å­—æ®µçš„æè¿°ä¿¡æ¯
    char[] c = context.buffer;
    int access = readUnsignedShort(u);
    String name = readUTF8(u + 2, c);
    String desc = readUTF8(u + 4, c);
    u += 6;

    // 2ã€è¯»å–å­—æ®µçš„å±æ€§
    String signature = null;
    int anns = 0;
    int ianns = 0;
    int tanns = 0;
    int itanns = 0;
    Object value = null;
    Attribute attributes = null;

    for (int i = readUnsignedShort(u); i > 0; --i) {
        String attrName = readUTF8(u + 2, c);
        // tests are sorted in decreasing frequency order
        // (based on frequencies observed on typical classes)
        if ("ConstantValue".equals(attrName)) {
            int item = readUnsignedShort(u + 8);
            value = item == 0 ? null : readConst(item, c);
        } else if (SIGNATURES && "Signature".equals(attrName)) {
            signature = readUTF8(u + 8, c);
        } else if ("Deprecated".equals(attrName)) {
            access |= Opcodes.ACC_DEPRECATED;
        } else if ("Synthetic".equals(attrName)) {
            access |= Opcodes.ACC_SYNTHETIC
                    | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
        } else if (ANNOTATIONS
                && "RuntimeVisibleAnnotations".equals(attrName)) {
            anns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeVisibleTypeAnnotations".equals(attrName)) {
            tanns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleAnnotations".equals(attrName)) {
            ianns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleTypeAnnotations".equals(attrName)) {
            itanns = u + 8;
        } else {
            Attribute attr = readAttribute(context.attrs, attrName, u + 8,
                    readInt(u + 4), c, -1, null);
            if (attr != null) {
                attr.next = attributes;
                attributes = attr;
            }
        }
        u += 6 + readInt(u + 4);
    }
    u += 2;

    // 3ã€è®¿é—®å­—æ®µçš„å£°æ˜
    FieldVisitor fv = classVisitor.visitField(access, name, desc,
            signature, value);
    if (fv == null) {
        return u;
    }

    // 4ã€è®¿é—®å­—æ®µçš„æ³¨è§£å’Œç±»å‹æ³¨è§£
    if (ANNOTATIONS && anns != 0) {
        for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    fv.visitAnnotation(readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && ianns != 0) {
        for (int i = readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    fv.visitAnnotation(readUTF8(v, c), false));
        }
    }
    if (ANNOTATIONS && tanns != 0) {
        for (int i = readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    fv.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && itanns != 0) {
        for (int i = readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    fv.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), false));
        }
    }

    // 5ã€è®¿é—®å­—æ®µçš„å±æ€§
    while (attributes != null) {
        Attribute attr = attributes.next;
        attributes.next = null;
        fv.visitAttribute(attributes);
        attributes = attr;
    }

    // è®¿é—®å­—æ®µç»“æŸæ—¶è°ƒç”¨
    fv.visitEnd();

    return u;
}
```
åŒè¯»å–ç±»ä¿¡æ¯çš„æ—¶å€™ç±»ä¼¼ï¼Œé¦–å…ˆï¼Œ

åœ¨æ³¨é‡Š1å’Œæ³¨é‡Š2å¤„ï¼Œä¼š å…ˆå¼€å§‹è¿›è¡Œå­—æ®µç›¸å…³çš„å­—èŠ‚ç è§£æçš„å·¥ä½œï¼š**è¯»å–äº†å­—æ®µçš„æè¿°å’Œå±æ€§ä¿¡æ¯**ã€‚ç„¶åï¼Œ

åœ¨æ³¨é‡Š3 ~ æ³¨é‡Š5å¤„ **æŒ‰é¡ºåºè®¿é—®äº†å­—æ®µçš„æè¿°ã€æ³¨è§£ã€ç±»å‹æ³¨è§£åŠå…¶å±æ€§ä¿¡æ¯**ã€‚æœ€åï¼Œè°ƒç”¨äº† FieldVisitor å®ä¾‹çš„ visitEnd æ–¹æ³•ç»“æŸäº†å­—æ®µä¿¡æ¯çš„è®¿é—®ã€‚

- 2.**è®¿é—®æ–¹æ³•**

readMethod

```java
/**
 * Reads a method and makes the given visitor visit it.
 * 
 * @param classVisitor
 *            the visitor that must visit the method.
 * @param context
 *            information about the class being parsed.
 * @param u
 *            the start offset of the method in the class file.
 * @return the offset of the first byte following the method in the class.
 */
private int readMethod(final ClassVisitor classVisitor,
        final Context context, int u) {
    // 1ã€è¯»å–æ–¹æ³•æè¿°ä¿¡æ¯
    char[] c = context.buffer;
    context.access = readUnsignedShort(u);
    context.name = readUTF8(u + 2, c);
    context.desc = readUTF8(u + 4, c);
    u += 6;

    // 2ã€è¯»å–æ–¹æ³•å±æ€§ä¿¡æ¯
    int code = 0;
    int exception = 0;
    String[] exceptions = null;
    String signature = null;
    int methodParameters = 0;
    int anns = 0;
    int ianns = 0;
    int tanns = 0;
    int itanns = 0;
    int dann = 0;
    int mpanns = 0;
    int impanns = 0;
    int firstAttribute = u;
    Attribute attributes = null;

    for (int i = readUnsignedShort(u); i > 0; --i) {
        String attrName = readUTF8(u + 2, c);
        // tests are sorted in decreasing frequency order
        // (based on frequencies observed on typical classes)
        if ("Code".equals(attrName)) {
            if ((context.flags & SKIP_CODE) == 0) {
                code = u + 8;
            }
        } else if ("Exceptions".equals(attrName)) {
            exceptions = new String[readUnsignedShort(u + 8)];
            exception = u + 10;
            for (int j = 0; j < exceptions.length; ++j) {
                exceptions[j] = readClass(exception, c);
                exception += 2;
            }
        } else if (SIGNATURES && "Signature".equals(attrName)) {
            signature = readUTF8(u + 8, c);
        } else if ("Deprecated".equals(attrName)) {
            context.access |= Opcodes.ACC_DEPRECATED;
        } else if (ANNOTATIONS
                && "RuntimeVisibleAnnotations".equals(attrName)) {
            anns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeVisibleTypeAnnotations".equals(attrName)) {
            tanns = u + 8;
        } else if (ANNOTATIONS && "AnnotationDefault".equals(attrName)) {
            dann = u + 8;
        } else if ("Synthetic".equals(attrName)) {
            context.access |= Opcodes.ACC_SYNTHETIC
                    | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleAnnotations".equals(attrName)) {
            ianns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleTypeAnnotations".equals(attrName)) {
            itanns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeVisibleParameterAnnotations".equals(attrName)) {
            mpanns = u + 8;
        } else if (ANNOTATIONS
                && "RuntimeInvisibleParameterAnnotations".equals(attrName)) {
            impanns = u + 8;
        } else if ("MethodParameters".equals(attrName)) {
            methodParameters = u + 8;
        } else {
            Attribute attr = readAttribute(context.attrs, attrName, u + 8,
                    readInt(u + 4), c, -1, null);
            if (attr != null) {
                attr.next = attributes;
                attributes = attr;
            }
        }
        u += 6 + readInt(u + 4);
    }
    u += 2;

    // 3ã€è®¿é—®æ–¹æ³•æè¿°ä¿¡æ¯
    MethodVisitor mv = classVisitor.visitMethod(context.access,
            context.name, context.desc, signature, exceptions);
    if (mv == null) {
        return u;
    }

    /*
     * if the returned MethodVisitor is in fact a MethodWriter, it means
     * there is no method adapter between the reader and the writer. If, in
     * addition, the writers constant pool was copied from this reader
     * (mw.cw.cr == this), and the signature and exceptions of the method
     * have not been changed, then it is possible to skip all visit events
     * and just copy the original code of the method to the writer (the
     * access, name and descriptor can have been changed, this is not
     * important since they are not copied as is from the reader).
     */
    if (WRITER && mv instanceof MethodWriter) {
        MethodWriter mw = (MethodWriter) mv;
        if (mw.cw.cr == this && signature == mw.signature) {
            boolean sameExceptions = false;
            if (exceptions == null) {
                sameExceptions = mw.exceptionCount == 0;
            } else if (exceptions.length == mw.exceptionCount) {
                sameExceptions = true;
                for (int j = exceptions.length - 1; j >= 0; --j) {
                    exception -= 2;
                    if (mw.exceptions[j] != readUnsignedShort(exception)) {
                        sameExceptions = false;
                        break;
                    }
                }
            }
            if (sameExceptions) {
                /*
                 * we do not copy directly the code into MethodWriter to
                 * save a byte array copy operation. The real copy will be
                 * done in ClassWriter.toByteArray().
                 */
                mw.classReaderOffset = firstAttribute;
                mw.classReaderLength = u - firstAttribute;
                return u;
            }
        }
    }

    // 4ã€è®¿é—®æ–¹æ³•å‚æ•°ä¿¡æ¯
    if (methodParameters != 0) {
        for (int i = b[methodParameters] & 0xFF, v = methodParameters + 1; i > 0; --i, v = v + 4) {
            mv.visitParameter(readUTF8(v, c), readUnsignedShort(v + 2));
        }
    }

    // 5ã€è®¿é—®æ–¹æ³•çš„æ³¨è§£ä¿¡æ¯
    if (ANNOTATIONS && dann != 0) {
        AnnotationVisitor dv = mv.visitAnnotationDefault();
        readAnnotationValue(dann, c, null, dv);
        if (dv != null) {
            dv.visitEnd();
        }
    }
    if (ANNOTATIONS && anns != 0) {
        for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    mv.visitAnnotation(readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && ianns != 0) {
        for (int i = readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
            v = readAnnotationValues(v + 2, c, true,
                    mv.visitAnnotation(readUTF8(v, c), false));
        }
    }
    if (ANNOTATIONS && tanns != 0) {
        for (int i = readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    mv.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), true));
        }
    }
    if (ANNOTATIONS && itanns != 0) {
        for (int i = readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
            v = readAnnotationTarget(context, v);
            v = readAnnotationValues(v + 2, c, true,
                    mv.visitTypeAnnotation(context.typeRef,
                            context.typePath, readUTF8(v, c), false));
        }
    }
    if (ANNOTATIONS && mpanns != 0) {
        readParameterAnnotations(mv, context, mpanns, true);
    }
    if (ANNOTATIONS && impanns != 0) {
        readParameterAnnotations(mv, context, impanns, false);
    }

    // 6ã€è®¿é—®æ–¹æ³•çš„å±æ€§ä¿¡æ¯
    while (attributes != null) {
        Attribute attr = attributes.next;
        attributes.next = null;
        mv.visitAttribute(attributes);
        attributes = attr;
    }

    // 7ã€è®¿é—®æ–¹æ³•ä»£ç å¯¹åº”çš„å­—èŠ‚ç ä¿¡æ¯
    if (code != 0) {
        mv.visitCode();
        readCode(mv, context, code);
    }

    // 8ã€visits the end of the method
    mv.visitEnd();

    return u;
}
```

**åŒç±»å’Œå­—æ®µçš„è¯»å–ã€è®¿é—®å¥—è·¯ä¸€æ ·**ï¼Œ

é¦–å…ˆï¼Œåœ¨**æ³¨é‡Š1å’Œæ³¨é‡Š2**å¤„ï¼Œä¼š å…ˆå¼€å§‹è¿›è¡Œæ–¹æ³•ç›¸å…³çš„å­—èŠ‚ç è§£æçš„å·¥ä½œï¼šè¯»å–äº†æ–¹æ³•çš„æè¿°å’Œå±æ€§ä¿¡æ¯ã€‚

ç„¶åï¼Œåœ¨**æ³¨é‡Š3 ~ æ³¨é‡Š7**å¤„ æŒ‰é¡ºåºè®¿é—®äº†æ–¹æ³•çš„æè¿°ã€å‚æ•°ã€æ³¨è§£ã€å±æ€§ã€æ–¹æ³•ä»£ç å¯¹åº”çš„å­—èŠ‚ç ä¿¡æ¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ readCode æ–¹æ³•ä¸­ï¼Œä¹Ÿæ˜¯å…ˆè¯»å–äº†æ–¹æ³•å†…éƒ¨ä»£ç çš„å­—èŠ‚ç ä¿¡æ¯ï¼Œä¾‹å¦‚å¤´éƒ¨ã€å±æ€§ç­‰ç­‰ï¼Œç„¶åï¼Œä¾¿ä¼šè®¿é—®å¯¹åº”çš„æŒ‡ä»¤é›†ã€‚

æœ€åï¼Œåœ¨**æ³¨é‡Š8å¤„** è°ƒç”¨äº† MethodVisitor å®ä¾‹çš„ visitEnd æ–¹æ³•ç»“æŸäº†æ–¹æ³•ä¿¡æ¯çš„è®¿é—®ã€‚

ä»ä»¥ä¸Šå¯¹ ClassVisitor ä¸ ClassReader çš„åˆ†æçœ‹æ¥ï¼ŒClassVisitor è¢«å®šä¹‰ä¸ºäº†ä¸€ä¸ªèƒ½æ¥æ”¶å¹¶è§£æ ClassReader ä¼ å…¥ä¿¡æ¯çš„ç±»ã€‚å½“åœ¨ accpet æ–¹æ³•ä¸­ ClassVisitor è®¿é—® ClassReader æ—¶ï¼ŒClassReader ä¾¿ä¼šå…ˆå¼€å§‹å­—èŠ‚ç çš„è§£æå·¥ä½œï¼Œå¹¶å°†ä¿å­˜åœ¨å†…å­˜ä¸­çš„ç»“æœæºæºä¸æ–­åœ°é€šè¿‡è°ƒç”¨å„ç§ visitxxx æ–¹æ³•ä¼ å…¥åˆ° ClassVisitor ä¹‹ä¸­ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå…¶ä¸­ 
> åªæœ‰ visit è¿™ä¸ªæ–¹æ³•ä¸€å®šä¼šè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œå› ä¸ºå®ƒ è·å–äº†ç±»å¤´éƒ¨çš„æè¿°ä¿¡æ¯ï¼Œæ˜¾ç„¶æ˜“è§ï¼Œå®ƒå¿…ä¸å¯å°‘ï¼Œè€Œå¯¹äºå…¶å®ƒçš„ visitxxx æ–¹æ³•æ¥è¯´éƒ½ä¸èƒ½ç¡®å®šã€‚ä¾‹å¦‚å…¶ä¸­çš„ visitMethod æ–¹æ³•ï¼Œåªæœ‰å½“ ClassReader è§£æå‡ºä¸€ä¸ªæ–¹æ³•çš„å­—èŠ‚ç æ—¶ï¼Œæ‰ä¼šè°ƒç”¨ä¸€æ¬¡ visitMethod æ–¹æ³•ï¼Œå¹¶ç”±æ­¤ç”Ÿæˆä¸€ä¸ªæ–¹æ³•è®¿é—®è€… MethodVisitor çš„å®ä¾‹ã€‚

ç„¶åï¼Œè¿™ä¸ª MethodVisitor çš„å®ä¾‹ä¾¿ä¼šåŒ ClassVisitor ä¸€æ ·å¼€å§‹è®¿é—®å½“å‰æ–¹æ³•çš„å±æ€§ä¿¡æ¯ï¼Œå¯¹äº ClassVisitor æ¥è¯´ï¼Œå®ƒåªå¤„ç†å’Œç±»ç›¸å…³çš„äº‹ï¼Œè€Œæ–¹æ³•çš„äº‹æƒ…è¢«å¤–åŒ…ç»™äº† MethodVisitor è¿›è¡Œå¤„ç†ã€‚è¿™æ­£æ˜¯è®¿é—®è€…çš„ä¸€å¤§ä¼˜åŠ¿ï¼š**å°†è®¿é—®ä¸€ä¸ªå¤æ‚äº‹ç‰©çš„èŒè´£é€šè¿‡å„ä¸ªä¸åŒç±»å‹ä½†åˆç›¸äº’å…³è”çš„è®¿é—®è€…åˆ†å‰²å¼€æ¥ã€‚**

ç”±å‰å¯çŸ¥ï¼Œå¯¹è±¡æ¨¡å‹æ˜¯äº‹ä»¶æ¨¡å‹çš„ä¸€ä¸ªå°è£…ã€‚å…¶ä¸­çš„ ClassNode å…¶å®å°±æ˜¯ ClassVisitor çš„ä¸€ä¸ªå­ç±»ï¼Œå®ƒè´Ÿè´£å°† ClassReader ä¼ è¿›æ¥çš„ä¿¡æ¯è¿›è¡Œåˆ†ç±»å‚¨å­˜ã€‚åŒæ ·ï¼ŒMethodNode ä¹Ÿæ˜¯ MethodVisitor çš„ä¸€ä¸ªå­ç±»ï¼Œå®ƒè´Ÿè´£å°† ClassReader ä¼ è¿›æ¥çš„æ“ä½œç æŒ‡ä»¤ä¿¡æ¯è¿æ¥æˆä¸€ä¸ªåˆ—è¡¨å¹¶ä¿å­˜å…¶ä¸­

è€Œ ClassWriter ä¹Ÿæ˜¯ ClassVisitor çš„ä¸€ä¸ªå­ç±»ï¼Œä½†æ˜¯ï¼Œå®ƒå¹¶ä¸ä¼šå‚¨å­˜ä¿¡æ¯ï¼Œè€Œæ˜¯é©¬ä¸Šä¼šå°†ä¼ å…¥çš„ä¿¡æ¯è½¬è¯‘æˆå­—èŠ‚ç ï¼Œå¹¶åœ¨ä¹‹åéšæ—¶è¾“å‡ºå®ƒä»¬ã€‚å¯¹äº ClassReader è¿™ä¸ªè¢«è®¿é—®è€…æ¥è¯´ï¼Œå®ƒè´Ÿè´£è¯»å–æˆ‘ä»¬ä¼ å…¥çš„ç±»æ–‡ä»¶ä¸­çš„å­—èŠ‚æµæ•°æ®ï¼Œå¹¶æä¾›è§£ææµä¸­åŒ…å«çš„ä¸€åˆ‡ç±»å±æ€§ä¿¡æ¯çš„æ“ä½œã€‚

æœ€åï¼Œä¸ºäº†æ›´è¿›ä¸€æ­¥åœ°å°†æˆ‘ä»¬ä¸Šé¢æ‰€è®²è§£çš„ ClassReader ä¸ ClassVisitor çš„å·¥ä½œæœºåˆ¶æ›´åŠ å½¢è±¡åŒ–ï¼Œè¿™é‡Œå€Ÿç”¨ hakugyokurou çš„ä¸€å¼ æµç¨‹å›¾ç”¨äºå›é¡¾æ¢³ç†ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
æ³¨æ„ï¼šç¬¬äºŒä¸ª"å®ä¾‹åŒ–ï¼Œé€šè¿‡æ„é€ å‡½æ•°..."éœ€è¦å»æ‰

 **å°ç»“**
- 1ï¼‰ã€**ClassReader**ï¼šç”¨äºè¯»å–å·²ç»ç¼–è¯‘å¥½çš„ .class æ–‡ä»¶ã€‚
- 2ï¼‰ã€**ClassWriter**ï¼šç”¨äºé‡æ–°æ„å»ºç¼–è¯‘åçš„ç±»ï¼Œå¦‚ä¿®æ”¹ç±»åã€å±æ€§ä»¥åŠæ–¹æ³•ï¼Œä¹Ÿå¯ä»¥ç”Ÿæˆæ–°çš„ç±»çš„å­—èŠ‚ç æ–‡ä»¶ã€‚
- 3ï¼‰ã€å„ç§ Visitor ç±»ï¼šå¦‚ä¸Šæ‰€è¿°ï¼ŒCore API æ ¹æ®å­—èŠ‚ç ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡å¤„ç†ï¼Œå¯¹äºå­—èŠ‚ç æ–‡ä»¶ä¸­ä¸åŒçš„åŒºåŸŸæœ‰ä¸åŒçš„ Visitorï¼Œæ¯”å¦‚ç”¨äºè®¿é—®æ–¹æ³•çš„ MethodVisitorã€ç”¨äºè®¿é—®ç±»å˜é‡çš„ FieldVisitorã€ç”¨äºè®¿é—®æ³¨è§£çš„ AnnotationVisitor ç­‰ç­‰ã€‚ä¸ºäº†å®ç° AOPï¼Œå…¶é‡ç‚¹æ˜¯è¦çµæ´»è¿ç”¨ MethodVisitorã€‚


## å®æˆ˜è®­ç»ƒ
åœ¨å®æˆ˜ä¹‹å‰æˆ‘ä»¬è¿™é‡Œå…ˆæä¸‹ä¸€ä¸ªå·¥å…·ï¼š`ASM Bytecode Viewer`

![ASMBytecodeViewer.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d722f2a3be48f695fa4ea3d221a4c0~tplv-k3u1fbpfcp-watermark.image?)
è¿™ä¸ªå·¥å…·å¯ä»¥ç»™æˆ‘ä»¬æä¾›éœ€è¦æ’å…¥çš„å­—èŠ‚ç çš„ASMæ“ä½œç 

ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿæˆ‘ä»¬åœ¨å®ç°ç±»è®¿é—®è€…çš„æ—¶å€™ï¼Œ**éœ€è¦å®ç°ä¸€ç³»åˆ— visitXXXXInsn() æ–¹æ³•ã€å¦‚æœè¦æ‰‹å†™æ¯è¡Œçš„ASMçš„ä»£ç ï¼Œéœ€è¦å¯¹ASMå’ŒJVMå­—èŠ‚ç æœ‰å¾ˆé«˜çš„è¦æ±‚ï¼Œ
äºæ˜¯è¿™é‡Œçš„ASM Bytecode Viewerå·¥å…·å°±æ˜¯å¸®åŠ©æˆ‘ä»¬å®ç°è¿™ä¸ªç¹ççš„è½¬æ¢è¿‡ç¨‹**.

åœ¨ASä¸­å®‰è£…å¥½ASM Bytecode Vieweræ’ä»¶åï¼Œé‡å¯å°±å¯ä»¥ä½¿ç”¨æˆ‘ä»¬çš„ASM Bytecode Vieweræ’ä»¶äº†ã€‚
æ’ä»¶å®ç°çš„åŠŸèƒ½å¦‚å›¾ï¼š

![Vieweræ•ˆæœ.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51efa03b2134deb872a12712fad79ba~tplv-k3u1fbpfcp-watermark.image?)
è¿˜å¯ä»¥å¯¹æ¯”å‰åä¸¤æ¬¡ç‰ˆæœ¬å·®å¼‚

![å¯¹æ¯”.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58d5163871bb42a8bb64167d1448a849~tplv-k3u1fbpfcp-watermark.image?)
ç„¶åå°±å¯ä»¥æ ¹æ®å‰åä¸¤æ¬¡å·®è·åœ¨ç±»è®¿é—®çš„æ—¶å€™ï¼Œå†™å…¥å·®å¼‚å…ƒç´ å³å¯

æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªDemoæ¥æµ‹è¯•ASMçš„äº‹ä»¶æ¨¡å‹

### 1.åœ¨æ‰€æœ‰æ–¹æ³•å‰é¢æ’å…¥æ—¥å¿—ç»Ÿè®¡æ–¹æ³•è€—æ—¶ï¼š

è¦å®ç°å­—èŠ‚ç æ’åº„éœ€è¦æœ‰å‡ ä¸ªæ­¥éª¤
- 1.è‡ªå®šä¹‰Gradle Pluginï¼Œå¹¶æ³¨å…¥ä¸€ä¸ªTransformã€‚
- 2.å°†TransformæŒ‚æ¥åˆ°Gradleç”Ÿå‘½å‘¨æœŸä¸­
- 3.éå†æ‰€æœ‰çš„classæ–‡ä»¶å’ŒjaråŒ…ä¸­çš„classæ–‡ä»¶
- 4.ä½¿ç”¨ASMä¿®æ”¹å­—èŠ‚ç ï¼Œå¹¶å†™å…¥æ–°çš„classæ–‡ä»¶ä¸­
- 5.Gradleæ„å»ºå·¥å…·ä½¿ç”¨æ–°çš„classæ–‡ä»¶æ‰“åŒ…åˆ°dexæ–‡ä»¶ä¸­

#### æ­¥éª¤1ï¼šåˆ›å»ºä¸€ä¸ªASMPluginç”¨äºæ³¨å…¥æˆ‘ä»¬çš„ASMTraceTransform

```java
class ASMPlugin implements Plugin<Project> {
    private static final String TAG = "ASMPlugin"

    @Override
    void apply(Project project) {

        if (!project.plugins.hasPlugin('com.android.application')) {
            throw new GradleException('ASM Plugin, Android Application plugin required')
        }

        project.afterEvaluate {
            def android = project.extensions.android
            android.applicationVariants.all { variant ->
                ASMTraceTransform.inject(project, variant)
            }
        }
    }
}
```

#### æ­¥éª¤2ï¼šå°†TransformæŒ‚æ¥åˆ°Gradleç”Ÿå‘½å‘¨æœŸä¸­

è¿™é‡Œä½¿ç”¨ï¼šä¸ºæ¯ä¸ªå˜ç§çš„afterEvaluateé˜¶æ®µæ³¨å…¥äº†ä¸€ä¸ªASMTraceTransform

```java
project.afterEvaluate {
	def android = project.extensions.android
	android.applicationVariants.all { variant ->
		ASMTraceTransform.inject(project, variant)
	}
}

public static void inject(Project project, def variant) {

	String hackTransformTaskName = getTransformTaskName(
			 "",
			"",variant.name
	)

	String hackTransformTaskNameForWrapper = getTransformTaskName(
			 "",
			"Builder",variant.name
	)

	project.logger.info("prepare inject dex transform :" + hackTransformTaskName +" hackTransformTaskNameForWrapper:"+hackTransformTaskNameForWrapper)

	project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
		@Override
		public void graphPopulated(TaskExecutionGraph taskGraph) {
			for (Task task : taskGraph.getAllTasks()) {
				if ((task.name.equalsIgnoreCase(hackTransformTaskName) || task.name.equalsIgnoreCase(hackTransformTaskNameForWrapper))
						&& !(((TransformTask) task).getTransform() instanceof ASMTraceTransform)) {
					project.logger.warn("find dex transform. transform class: " + task.transform.getClass() + " . task name: " + task.name)
					project.logger.info("variant name: " + variant.name)
					Field field = TransformTask.class.getDeclaredField("transform")
					field.setAccessible(true)
					field.set(task, new ASMTraceTransform(project, variant, task.transform))
					project.logger.warn("transform class after hook: " + task.transform.getClass())
					break
				}
			}
		}
	})
}
```

è·å–æˆ‘ä»¬éœ€è¦hackçš„TransformTaskåç§°ï¼š
`transformClassesWithDexFordebug` æˆ–è€…`transformClassesWithDexBuilderFordebug`

ç„¶åä½¿ç”¨åå°„:å°†æˆ‘ä»¬çš„ASMTraceTransformæ›¿æ¢ä¸ºTransformTaskä¸­çš„transformå­—æ®µå±æ€§,è¿™æ ·ä»»åŠ¡åœ¨æ‰§è¡Œåˆ°transformClassesWithDexFordebugæˆ–è€…transformClassesWithDexBuilderFordebugçš„æ—¶å€™å°±ä¼šæ‰§è¡Œå½“å‰ASMTraceTransformçš„transformæ–¹æ³•

```java
field.set(task, new ASMTraceTransform(project, variant, task.transform))
```

#### æ­¥éª¤3ï¼šéå†æ‰€æœ‰çš„classæ–‡ä»¶å’ŒjaråŒ…ä¸­çš„classæ–‡ä»¶
æ¥çœ‹ASMTraceTransformçš„transformæ–¹æ³•

```java
public void transform(TransformInvocation transformInvocation){
	...
	//è¿™é‡Œå°†è¾“å…¥çš„classæ–‡ä»¶è¿›è¡Œè·¯å¾„å¤åˆ¶
	transformInvocation.inputs.each { TransformInput input ->
		input.directoryInputs.each { DirectoryInput dirInput ->
			collectAndIdentifyDir(scrInputMap, dirInput, rootOutput, isIncremental)
		}
		input.jarInputs.each { JarInput jarInput ->
			if (jarInput.getStatus() != Status.REMOVED) {
				collectAndIdentifyJar(jarInputMap, scrInputMap, jarInput, rootOutput, isIncremental)
			}
		}
	}
	
	MethodTracer methodTracer = new MethodTracer()
	//è¿™ä¸ªæ–¹æ³•å†…éƒ¨ä¼šå¯¹å­—èŠ‚ç è¿›è¡Œæ ¡éªŒ
	methodTracer.trace(scrInputMap, jarInputMap)
	origTransform.transform(transformInvocation)
	...

}
```

#### æ­¥éª¤4ï¼šä½¿ç”¨ASMä¿®æ”¹å­—èŠ‚ç ï¼Œå¹¶å†™å…¥æ–°çš„classæ–‡ä»¶ä¸­
MethodTracerå†…éƒ¨ä¼šå¯¹æ‰€æœ‰classæ–‡ä»¶è¿›è¡Œéå†æ“ä½œï¼šä¿®æ”¹å­—èŠ‚ç 

```java
private void innerTraceMethodFromSrc(File input, File output) {
	is = new FileInputStream(classFile);
	//æ ¸å¿ƒæ–¹æ³•ASMCode.run
	ClassWriter classWriter = ASMCode.run(is);
	if (output.isDirectory()) {
		os = new FileOutputStream(changedFileOutput);
	} else {
		os = new FileOutputStream(output);
	}
	os.write(classWriter.toByteArray());
}
runæ–¹æ³•:è¿™å°±æ˜¯å‰é¢è¯´çš„æ¨¡æ¿æ–¹æ³•
public static ClassWriter run(InputStream is) throws IOException {
	ClassReader classReader = new ClassReader(is);
	ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
	ClassVisitor classVisitor = new TraceClassAdapter(Opcodes.ASM5, classWriter);
	classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);
	return classWriter;
}
è¿™é‡Œä½¿ç”¨äº†TraceClassAdapterï¼Œä¹Ÿæ˜¯ç»§æ‰¿ClassVisitor
public static class TraceClassAdapter extends ClassVisitor {

	private String className;

	TraceClassAdapter(int i, ClassVisitor classVisitor) {
		super(i, classVisitor);
	}


	@Override
	public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
		super.visit(version, access, name, signature, superName, interfaces);
		this.className = name;

	}

	@Override
	public void visitInnerClass(final String s, final String s1, final String s2, final int i) {
		super.visitInnerClass(s, s1, s2, i);
	}

	@Override
	public MethodVisitor visitMethod(int access, String name, String desc,
									 String signature, String[] exceptions) {

		MethodVisitor methodVisitor = cv.visitMethod(access, name, desc, signature, exceptions);
		return new TraceMethodAdapter(api, methodVisitor, access, name, desc, this.className);
	}


	@Override
	public void visitEnd() {
		super.visitEnd();
	}
}

```

**ä¸»è¦æ¥çœ‹visitMethodæ–¹æ³•**ï¼š
ä½¿ç”¨äº†ä¸€ä¸ªåŒ…è£¹ç±»TraceMethodAdapterå°†methodVisitorå°è£…åœ¨å…¶å†…éƒ¨

```java
public static class TraceMethodAdapter extends AdviceAdapter {

	private final String methodName;
	private final String className;
	private boolean find = false;


	protected TraceMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {
		super(api, mv, access, name, desc);
		this.className = className;
		this.methodName = name;
	}

	@Override
	public void visitTypeInsn(int opcode, String s) {
		super.visitTypeInsn(opcode, s);
	}

	@Override
	public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
		super.visitMethodInsn(opcode, owner, name, desc, itf);
	}

	private int timeLocalIndex = 0;

	@Override
	protected void onMethodEnter() {
		mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
		timeLocalIndex = newLocal(Type.LONG_TYPE); //this is a function promotes by LocalVariablesSorter ,you can use old LocalVariables
		mv.visitVarInsn(LSTORE, timeLocalIndex);
	}

	@Override
	protected void onMethodExit(int opcode) {
		mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
		mv.visitVarInsn(LLOAD, timeLocalIndex);
		mv.visitInsn(LSUB);//its on the top of stack table
		mv.visitVarInsn(LSTORE, timeLocalIndex);//you will use this value a time later,so you can store it to the LocalVariables info table


		int stringBuilderIndex = newLocal(Type.getType("java/lang/StringBuilder"));
		mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
		mv.visitInsn(Opcodes.DUP);
		mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
		mv.visitVarInsn(Opcodes.ASTORE, stringBuilderIndex);//store the stringbuilder of the stack top avoid to can not find it
		mv.visitVarInsn(Opcodes.ALOAD, stringBuilderIndex);
		mv.visitLdcInsn(className + "." + methodName + " time:");
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
		mv.visitInsn(Opcodes.POP);
		mv.visitVarInsn(Opcodes.ALOAD, stringBuilderIndex);
		mv.visitVarInsn(Opcodes.LLOAD, timeLocalIndex);
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
		mv.visitInsn(Opcodes.POP);
		mv.visitLdcInsn("Geek");
		mv.visitVarInsn(Opcodes.ALOAD, stringBuilderIndex);
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
		mv.visitMethodInsn(Opcodes.INVOKESTATIC, "android/util/Log", "d", "(Ljava/lang/String;Ljava/lang/String;)I", false);
		//cautionï¼šLog.d has return value ,should pop
		mv.visitInsn(Opcodes.POP);
		//After inserting the bytecode, it is necessary to ensure that the stack is clean and does not affect the original logic. Otherwise, an exception will occur, and it will also affect the processing of bytecode by other frameworks.
	}
}

```

`onMethodEnter`:**åœ¨æ–¹æ³•å¼€å§‹ä½ç½®æ’å…¥å­—èŠ‚ç **

`onMethodExit`ï¼š**åœ¨æ–¹æ³•ç»“æŸä½ç½®æ’å…¥å­—èŠ‚ç **

è¿™ä¸ªå­—èŠ‚ç å°±æ˜¯å‰é¢ä½¿ç”¨ASM Bytecode Viewerç”Ÿæˆçš„å·®å¼‚ä»£ç 
![å¯¹æ¯”.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a82e15481c24d2e934f223a365cb978~tplv-k3u1fbpfcp-watermark.image?)


æ¥çœ‹ä¸‹ç”Ÿæˆçš„å­—èŠ‚ç ï¼š

```java
public class SampleApplication extends Application {
    public SampleApplication() {
        long var1 = System.currentTimeMillis();
        var1 = System.currentTimeMillis() - var1;
        StringBuilder var3 = new StringBuilder();
        var3.append("com/sample/asm/SampleApplication.<init> time:");
        var3.append(var1);
        Log.d("Geek", var3.toString());
    }

    public void onCreate() {
        long var1 = System.currentTimeMillis();
        super.onCreate();
        var1 = System.currentTimeMillis() - var1;
        StringBuilder var3 = new StringBuilder();
        var3.append("com/sample/asm/SampleApplication.onCreate time:");
        var3.append(var1);
        Log.d("Geek", var3.toString());
    }
	...
}
```

å¯ä»¥çœ‹åˆ°å…¶åœ¨æ‰€æœ‰çš„ç±»çš„æ‰€æœ‰æ–¹æ³•ä¸­éƒ½æ’å…¥äº†ä»¥ä¸‹ä»£ç ï¼š

```java
long var1 = System.currentTimeMillis();
var1 = System.currentTimeMillis() - var1;
StringBuilder var3 = new StringBuilder();
var3.append("com/sample/asm/SampleApplication.onCreate time:");
var3.append(var1);
Log.d("Geek", var3.toString());

```
### 2.å°†ç±»ä¸­æ‰€æœ‰çš„Threadæ›¿æ¢ä¸ºè‡ªå®šä¹‰çš„CustomThread
è¿™ä¸ªåªéœ€è¦æ”¹å˜TraceMethodAdapterä¸­çš„è®¿é—®æ–¹æ³•å³å¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
private final String methodName;
private final String className;
// æ ‡è¯†æ˜¯å¦é‡åˆ°äº† new æŒ‡ä»¤
private boolean find = false;

protected TraceMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {
    super(api, mv, access, name, desc);
    this.className = className;
    this.methodName = name;
}

@Override
public void visitTypeInsn(int opcode, String s) {
    // æ–¹æ³•å¯ä»¥åƒç±»ä¸€æ ·å°±è¡Œè½¬æ¢ï¼Œä¾‹å¦‚ï¼Œé€šè¿‡ä½¿ç”¨ä¸€ä¸ªæ–¹æ³•é€‚é…å™¨æ¥è½¬å‘ 
    // é‚£äº›å¸¦æœ‰ä¿®æ”¹çš„æ–¹æ³•è°ƒç”¨:æ”¹å˜å‚æ•°å¯ä»¥è¢«ç”¨æ¥å˜æ›´æŒ‡ä»¤ï¼Œä¸è½¬å‘
    // æŸä¸ªæ–¹æ³•è°ƒç”¨å¯ä»¥åˆ é™¤ä¸€ ä¸ªæŒ‡ä»¤ï¼Œæ’å…¥æ–°çš„è°ƒç”¨å¯ä»¥æ·»åŠ æ–°çš„æŒ‡ä»¤
    if (opcode == Opcodes.NEW && "java/lang/Thread".equals(s)) {
        // é‡åˆ° new æŒ‡ä»¤
        find = true;
        mv.visitTypeInsn(Opcodes.NEW, "com/sample/asm/CustomThread");
            return;
    }
    super.visitTypeInsn(opcode, s);
}

@Override
public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
    //éœ€è¦æ’æŸ¥ CustomThread è‡ªå·±
    if ("java/lang/Thread".equals(owner) && !className.equals("com/sample/asm/CustomThread") && opcode == Opcodes.INVOKESPECIAL && find) {
        find = false;
        mv.visitMethodInsn(opcode, "com/sample/asm/CustomThread", name, desc, itf);
        Log.e("asmcode", "className:%s, method:%s, name:%s", className, methodName, name);
            return;
    }
    super.visitMethodInsn(opcode, owner, name, desc, itf);
}
```

åœ¨ä½¿ç”¨ ASM è¿›è¡Œæ’æ¡©çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°¤å…¶éœ€è¦æ³¨æ„ä»¥ä¸‹ ä¸¤ç‚¹ï¼š
- 1ï¼‰ã€**å½“æˆ‘ä»¬ä½¿ç”¨ ASM å¤„ç†å­—èŠ‚ç æ—¶ï¼Œéœ€è¦ é€æ­¥å°é‡çš„ä¿®æ”¹ã€éªŒè¯ï¼Œåˆ‡è®°ä¸è¦ç¼–å†™å¤§é‡çš„å­—èŠ‚ç å¹¶å¸Œæœ›å®ƒä»¬èƒ½å¤Ÿç«‹å³é€šè¿‡éªŒè¯å¹¶ä¸”å¯ä»¥é©¬ä¸Šæ‰§è¡Œã€‚æ¯”è¾ƒç¨³å¦¥çš„åšæ³•æ˜¯ï¼Œæ¯ç¼–å†™ä¸€è¡Œå­—èŠ‚ç æ—¶å°±è€ƒè™‘ä¸€ä¸‹æ“ä½œæ•°æ ˆä¸å±€éƒ¨å˜é‡è¡¨ä¹‹é—´çš„å˜åŒ–æƒ…å†µï¼Œç¡®å®šæ— è¯¯ä¹‹åå†å†™ä¸‹ä¸€è¡Œã€‚æ­¤å¤–ï¼Œé™¤äº† JVM çš„éªŒè¯å™¨ä¹‹å¤–ï¼ŒASM è¿˜ç»´æŠ¤äº†ä¸€ä¸ªå•ç‹¬çš„å­—èŠ‚ç éªŒè¯å™¨ï¼Œå®ƒä¹Ÿä¼šæ£€æŸ¥ä½ çš„å­—èŠ‚ç å®ç°æ˜¯å¦ç¬¦åˆ JVM è§„èŒƒ**ã€‚
- 2ï¼‰ã€**æ³¨æ„æœ¬åœ°å˜é‡è¡¨å’Œæ“ä½œæ•°æ ˆçš„æ•°æ®äº¤æ¢ä»¥åŠ try catch blcok çš„å¤„ç†ï¼Œå…³äºå¼‚å¸¸å¤„ç†å¯ä»¥ä½¿ç”¨ ASM æä¾›çš„ CheckClassAdapterï¼Œå¯ä»¥åœ¨ä¿®æ”¹å®ŒæˆåéªŒè¯ä¸€ä¸‹å­—èŠ‚ç æ˜¯å¦æ­£å¸¸**ã€‚
## 7.0 ä»¥åTransformè¢«åºŸå¼ƒ
`AGP7.0`ä¸­`Transform`å·²ç»è¢«æ ‡è®°ä¸ºåºŸå¼ƒäº†ï¼Œå¹¶ä¸”å°†åœ¨`AGP8.0`ä¸­ç§»é™¤ï¼Œé‚£æˆ‘ä»¬å¦‚ä½•å»é€‚é…å‘¢ï¼Ÿ
ä½¿ç”¨Transform Actionæˆ–è€…## `AsmClassVisitorFactory`
Transform Actionå•ç‹¬ä½¿ç”¨èµ·æ¥æ¯”è¾ƒéº»çƒ¦ï¼Œå’Œæˆ‘ä»¬äº‹ä»¶æ¨¡å‹ç±»ä¼¼ï¼Œæˆ‘ä»¬è¿™é‡Œå¯ä»¥ä½¿ç”¨AsmClassVisitorFactoryæ¥å¤„ç†ï¼ŒAsmClassVisitorFactoryæ˜¯åœ¨Transform Actionåšçš„ä¸€å±‚å°è£…ï¼Œå¯ä»¥ä¸éœ€è¦å†å¤„ç†å¢é‡ç¼–è¯‘ç›¸å…³ã€‚
æ ¹æ®å®˜æ–¹çš„è¯´æ³•ï¼Œ`AsmClassVisitoFactory`ä¼šå¸¦æ¥çº¦18%çš„æ€§èƒ½æå‡ï¼ŒåŒæ—¶å¯ä»¥å‡å°‘çº¦5å€ä»£ç 

**å…¶å®æ ¸å¿ƒå¤„ç†é‚£å—éƒ½æ²¡æœ‰å˜ï¼Œåªæ˜¯æ³¨å†Œæ–¹å¼æ”¹å˜äº†ï¼Œä¸”ä¸éœ€è¦å•ç‹¬å¤„ç†å¢é‡ç¼–è¯‘ç›¸å…³çŸ¥è¯†**


å…·ä½“ä»£ç é€‚é…å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ï¼š
[Transform è¢«åºŸå¼ƒï¼ŒASM å¦‚ä½•é€‚é…?](https://juejin.cn/post/7105925343680135198)


## æ€»ç»“

**åœ¨ ASM Bytecode Outline å·¥å…·çš„å¸®åŠ©ä¸‹ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå®Œæˆå¾ˆå¤šåœºæ™¯ä¸‹çš„ ASM æ’æ¡©çš„éœ€æ±‚ï¼Œä½†æ˜¯ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨å…¶å¤„ç†å­—èŠ‚ç çš„æ—¶å€™è¿˜æ˜¯éœ€è¦è€ƒè™‘å¾ˆå¤šç§å¯èƒ½å‡ºç°çš„æƒ…å†µã€‚å¦‚æœæƒ³è¦å…·å¤‡è¿™æ–¹é¢çš„æ·±åº¦æ€è€ƒèƒ½åŠ›ï¼Œæˆ‘ä»¬å°± å¿…é¡»å¯¹æ¯ä¸€ä¸ªæ“ä½œç çš„ç‰¹å¾éƒ½æœ‰è¾ƒæ·±çš„äº†è§£ï¼Œå¦‚æœè¿˜ä¸äº†è§£çš„åŒå­¦å¯ä»¥å»çœ‹çœ‹ ã€Šæ·±å…¥æ¢ç´¢ç¼–è¯‘æ’æ¡©æŠ€æœ¯ï¼ˆä¸‰ã€JVMå­—èŠ‚ç ï¼‰ã€‚å› æ­¤ï¼Œè¦å…·å¤‡å®ç°ä¸€ä¸ªå¤æ‚ ASM æ’æ¡©çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ JVM å­—èŠ‚ç ã€ASM å­—èŠ‚ç ä»¥åŠ ASM æºç ä¸­çš„æ ¸å¿ƒå·¥å…·ç±»çš„å®ç° åšåˆ°äº†ç„¶äºå¿ƒï¼Œå¹¶ä¸”åœ¨ä¸æ–­åœ°å®è·µä¸è¯•é”™ä¹‹åï¼Œæˆ‘ä»¬æ‰èƒ½å¤Ÿæˆä¸ºä¸€ä¸ªçœŸæ­£çš„ ASM æ’æ¡©é«˜æ‰‹ã€‚**


[ç¼–è¯‘æ’æ¡©DEMOåœ°å€](https://github.com/AndroidAdvanceWithGeektime/Chapter-ASM)
## å‚è€ƒ

1ã€[ASMå®˜æ–¹æ–‡æ¡£](https://link.juejin.cn/?target=https%3A%2F%2Fasm.ow2.io%2F "https://asm.ow2.io/")

2.[æå®¢æ—¶é—´ä¹‹Androidå¼€å‘é«˜æ‰‹è¯¾ ç»ƒä¹ Sampleè·‘èµ·æ¥ | ASMæ’æ¡©å¼ºåŒ–ç»ƒä¹ ](https://link.juejin.cn/?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Farticle%2F83148 "https://time.geekbang.org/column/article/83148")

3. [ASMè§£è°œ](https://juejin.cn/post/6844904118700474375)




â€‹		