> 🔥 **Hi，我是小余。** **本文已收录到 [GitHub · Androider-Planet](https://github.com/ByteYuhb/Androider-Planet) 中。这里有 Android 进阶成长知识体系，关注公众号 [[小余的自习室](https://mp.weixin.qq.com/s?__biz=MzkwODI1NDEwMA==&mid=2247483986&idx=1&sn=57136c9c062caa1026edf9ed35915c2b&chksm=c0cd8ca9f7ba05bfcfadad10bd97006bbb57afdd048c9c46fe57d122af834f569aa9d8df0e48&token=2142008574&lang=zh_CN#rd)] ，在成功的路上不迷路！**

## 浅谈

怎么证明你是一个真正的程序员？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38433e1fbe2d45f59e2c1fd25b4ba642~tplv-k3u1fbpfcp-zoom-1.image)

如果你看不懂这个图片里面的意思，没关系，不妨先看下文章再回过头来看这个图片,你就懂了。

## 机器数和真值

### 机器数

一个数在计算中的二进制表示形式，叫做这个数的机器数，机器数是带符号的，正数为0，负数为1。

如 ：

-   十进制数+3，机器数就是00000000000000000000000000000011
-   十进制数-3，那机器数不就是10000000000000000000000000000011 ，想当然~ 实际是11111111111111111111111111111101，这个数是-3的补码形式，因为**负数在机器中是以补码的形式存在的。**

### 真值

真正数学意义上的数值。因为第一位是符号位，所以机器数形式值就不等于真正的数值。 如：

```
00000000000000000000000000000011->+3
11111111111111111111111111111101->-3
```

**当然前面的举例是针对有符号数来说的，对于无符号数，机器数和真值是一致的。**

#### 无符号数和有符号数机器数和真值换算方式

##### 无符号数换算：

用一个函数**B2Uw**（Binary to Unsigned）的缩写，长度为w来表示：

$$
B2U_{w}(\vec x) = \sum_{i=0}^{w-1}X_i2^i  
$$

  


如4位二进制数：

$$
B2U_4([0001]) = 0*2^3+0*2^2+0*2^1+1*2^0 = 0+0+0+1 =1  
$$

  


$$
B2U_4([0011]) = 0*2^3+0*2^2+1*2^1+1*2^0 = 0+0+2+1 = 3  
$$

  


$$
B2U_4([1001]) = 1*2^3+0*2^2+0*2^1+1*2^0 = 8+0+0+1 =9  
$$

  


$$
B2U_4([1111]) = 1*2^3+1*2^2+1*2^1+1*2^0 = 8+4+2+1 =15  
$$

  


##### 有符号数换算方式

前面我们说过有符号数在计算机中的机器数是以补码的形式存在的，其换算公式**B2Tw**(Binary to Two`s complement)：

$$
B2T_{w}(\vec x) = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}X_i2^i  
$$

  


如下面4位二进制数：

$$
B2U_4([0001]) = -0*2^3+0*2^2+0*2^1+1*2^0 = -0 +0+0+1 =1  
$$

  


$$
B2U_4([0011]) = -0*2^3+0*2^2+1*2^1+1*2^0 = -0+0+2+1 =3  
$$

  


$$
B2U_4([1001]) = -1*2^3+0*2^2+0*2^1+1*2^0 = -8+0+0+1=-7  
$$

  


$$
B2U_4([1111]) = -1*2^3+1*2^2+1*2^1+1*2^0 = -8+4+2+1=-1  
$$

  


当然还有一种大众所知的方式：就是使**用原码，反码，补码变换规律**

## 原码，反码，补码

### 计算机机器数运行效率问题

首先要清楚我们计算机中统一使用的是加法计算，对你没听错。。计算机居然不会减法，哈哈。

在补码概念提出之前，我们来举几个例子：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e545c67e6ce46ce92adb2d68cb125de~tplv-k3u1fbpfcp-zoom-1.image)

**可以看到在有负数参与的加法计算得到的结果是有误的。**

如果需要得到正确的结果，计算器不得不是有其他方式去得到，这样必然就会影响运行效率。

为了解决负数在计算机中运行效率问题，科学家们提出了补码的概念。

### 补码：

#### 使用补码获取真值

那如何使用补码规则获取一个负数的真值呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7399a2d93624c33b53dd0c803231521~tplv-k3u1fbpfcp-zoom-1.image)

假设我们从计算中获取了一个二进制为10000001的8位机器数，如何获取其真值。

-   **step1**.首先10000001是指一个补码形式机器数，实际上在计算机系统中，所有的整数都是以补码的形式存在，包括正数和负数，正数的补码就是原码自己所以统一使用补码来存储。
-   **step2**.按照补码到反码规则，在补码10000001基础上-1，将得到反码：10000000
-   **step3**.按照反码到原码规则，将符合位不变，反码取反即可得原码：11111111
-   **step4**.按照原码的真值概念：原码的符合位为符号位，不参与计算，其他位为真值的绝对值即可：- 127

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f638e9e2967e43b491ab3d95689c79f8~tplv-k3u1fbpfcp-zoom-1.image)

#### 补码的计算逻辑

我们回到前面分析运行效率时举的正正，负负，正负相加例子：

这里我们使用补码再来计算下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ec27bd99b54dd58ab0ade18cfc6459~tplv-k3u1fbpfcp-zoom-1.image)

可以看出，将符号以补码的形式存储在计算机中之后就可以使用加法来代替减法的操作，大大提高了计算机的运行效率。

#### 补码的设计来源

通过文章前半部分介绍，相信你已经对补码有了一个比较全面的概念了，但是补码是怎么设计出来的呢？

数学里面有一个“补数”概念。

##### 补数

生活中有很多例子，只要是**带周期性的事务性质的都可以用补数来形容**。比如：时钟或者转盘等。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/466dd8e99685420e8d5f5b265e40c569~tplv-k3u1fbpfcp-zoom-1.image)

假设当前时间是2点，你要让时钟显示到12点，那么有两个方式。

-   **方式1**.将指针顺时针拨动10个点，做的是**加法**：+10。

<!---->

-   **方式2**.将指针逆时针拨动2个点，做的是**减法**：-2。

**对于时钟来说，不管你是方式1的加法运行还是方式2的减法运算，指针都指向了12点，实现的效果是一致的，** **那我们就说+10和-2是两个补数，它们的绝对值之和12就是补数的模**。

**这种规律也被应用到计算机二进制中**。下面我们使用一个例子来看：

假设要计算：（5）+（-1） = 5+(+?)

-   5在计算机中的原码： 0 0 0 0 0 1 0 1
-   -1在计算机中的原码：1 0 0 0 0 0 0 1

**要将这个减法操作变为加法操作，首要任务就是找到模，然后得到-1的正补数相加即可**。

来看我们的时钟，每拨动12格为一个周期，就是说复原了，一样的，**8bit位范围是-128~127**,（注意这里我们为了精简分析使用的是8位来测试计算，实际计算机中场景一般都是32位格式4个字节或者64位计算）所以**其一个周期就是256，也就是其模就是256**（1 0000 0000），不管你是加上256还是减少256，在二进制中，值都是不变的，因为最后一位是溢出位，不会去计算。

通过以上分析我们找到了-1（1 0 0 0 0 0 0 1）的模为256(1 0000 0000),-1的补数为（+255）：0 1111 1111

这样就将5-1这个减法运算变更为了5+255这个加法操作

下面我们来看5+255：

```
5:0000 0101

255：0 1111 1111 

二进制相加后：1 0000 0100 ->最高位溢出丢弃所以结果为4.
```

看到是不是和5-1结果一样呢？。

其实计算机中的补码也是这个模式：**找到一个与负数等价的正补数，使用该正补数代替负数，从而将减法运算替换为两个正数加法运算**，补码的出现与运算器的电路设计有关，从设计者的角度看，希望尽可能简化电路设计和计算复杂度。而使用正补数代替负数就可以消除减法器，实现简化电路的目的。

好了回过头来我们看看开始那幅图，你看懂了么？我是[小余](https://mp.weixin.qq.com/s?__biz=MzkwODI1NDEwMA==&mid=2247483986&idx=1&sn=57136c9c062caa1026edf9ed35915c2b&chksm=c0cd8ca9f7ba05bfcfadad10bd97006bbb57afdd048c9c46fe57d122af834f569aa9d8df0e48&token=2142008574&lang=zh_CN#rd)，我们下期见。

参考：[为什么计算机中的负数要用补码表示？](https://juejin.cn/post/7169966346753540103#heading-9)

。