> ğŸ”¥ **Hiï¼Œæˆ‘æ˜¯å°ä½™ã€‚**
>
> **æœ¬æ–‡å·²æ”¶å½•åˆ° [GitHub Â· Androider-Planet](https://github.com/ByteYuhb/Androider-Planet) ä¸­ã€‚è¿™é‡Œæœ‰ Android è¿›é˜¶æˆé•¿çŸ¥è¯†ä½“ç³»ï¼Œå…³æ³¨å…¬ä¼—å· [å°ä½™çš„è‡ªä¹ å®¤] ï¼Œåœ¨æˆåŠŸçš„è·¯ä¸Šä¸è¿·è·¯ï¼**
## å‰è¨€
æœ€è¿‘åœ¨`ç»„ä»¶åŒ–`å¼€å‘ä¸­å‡†å¤‡å°è£…ä¸€ä¸ª`å›¾ç‰‡åŠ è½½åº“`ï¼Œäºæ˜¯ä¹å°±æœ‰äº†è¿™ç¯‡æ–‡ç« 

æœ¬ç¯‡æ–‡ç« å¯¹`Glide`æºç è¿‡ç¨‹åšäº†ä¸€ä¸ªè¯¦ç»†çš„è®²è§£ï¼Œä¹Ÿæ˜¯ä¸ºäº†è®°å½•ä¸‹è‡ªå·±å¯¹`Glide`çš„ç†è§£ï¼Œä»¥åå¿˜è®°è¿˜å¯ä»¥ä»è¿™é‡ŒæŸ¥æ‰¾ã€‚

è¿™é‡Œæˆ‘æœ‰å‡ ç‚¹å»ºè®®ï¼š
- çœ‹æºç å‰å…ˆé—®ä¸‹è‡ªå·±ï¼š
ä½ ä¸ºä»€ä¹ˆå»çœ‹æºç ï¼Œæ˜¯ä¸ºäº†é¢è¯•ï¼Ÿå­¦ä¹ ï¼Ÿæˆ–è€…å’Œæˆ‘ä¸€æ ·ä¸ºäº†å°è£…ä¸€ä¸ªè‡ªå·±çš„å›¾ç‰‡åŠ è½½åº“ï¼Ÿ
å¦‚æœæ˜¯ä¸ºäº†é¢è¯•ï¼Œå»ºè®®å…ˆåˆ—å‡ºå‡ ç§åŒç±»å‹çš„å¼€æºåº“ï¼Œæ¯”å¦‚æˆ‘ä»¬çš„å›¾ç‰‡åŠ è½½åº“æœ‰Picassoï¼ŒFrescoå’ŒGlideï¼Œé¦–å…ˆä½ è¦çŸ¥é“ä»–ä»¬çš„åŸºæœ¬ä½¿ç”¨æ–¹å¼,èƒ½è¯´å‡ºä»–ä»¬çš„ä¼˜ç¼ºç‚¹ï¼Œå¹¶ä»ä¸­æŒ‘é€‰ä¸€ä¸ªç±»åº“å»æ·±å…¥äº†è§£ï¼Œå› ä¸ºé¢è¯•å®˜å¾ˆå¤§å¯èƒ½ä¼šè®©ä½ è‡ªå·±è®¾è®¡ä¸€å¥—ç±»ä¼¼çš„å¼€æºåº“ï¼Œé‚£è¿™ä¸ªæ—¶å€™ä½ æœ‰å¯¹æŸä¸ªç±»åº“åšè¿‡æ·±å…¥äº†è§£ï¼Œä¼šèµ·åˆ°äº‹åŠåŠŸå€çš„æ•ˆæœï¼Œå°±ç®—ä¸èƒ½å®Œæ•´è®¾è®¡å‡ºæ¥ï¼Œä¹Ÿå¯ä»¥è¯´å‡ºä¸€äº›åŸºæœ¬åŸç†å’Œå¤§è‡´çš„æ¶æ„ã€‚

**ä¸ªäººå¯¹çœ‹æºç çš„æ€è·¯:**

å…ˆçœ‹`æ•´ä½“æ¡†æ¶`ï¼šç„¶åæ‰¾åˆ°ä¸€ä¸ª`åˆ‡å…¥ç‚¹`ï¼Œæ·±å…¥æ¡†æ¶å†…éƒ¨å»å­¦ä¹ ã€‚å­¦ä¹ ä¸­é—´è®°å¾—æ ¹æ®æ¡†æ¶è¿›è¡Œ`åˆ†é˜¶æ®µæ€»ç»“`ï¼Œè¿™æ ·æ‰èƒ½ä¸ä¼šæ·±é™·ä»£ç æ³¥æ½­ã€‚å¥½äº†ä¸‹é¢æˆ‘ä»¬å¼€å§‹å§ã€‚ã€‚




## æ•´ä½“æ¡†æ¶å›¾

![glideæ•´ä½“æ¡†æ¶å›¾.awebp](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbbfaf9922414000842380f0250c72e7~tplv-k3u1fbpfcp-watermark.image?)

## æºç æ¢³ç†
æˆ‘ä»¬å°†æºç åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†æ¥è®²è§£ï¼š
`with` `load` å’Œ`into`
> è¿™ä¸ªä¸‰ä¸ªéƒ¨åˆ†å°±æ˜¯æˆ‘ä»¬çœ‹æºç çš„åˆ‡å…¥ç‚¹ï¼š

#### æ­¥éª¤1ï¼šwithï¼š
**Glide.java**

```java
public static RequestManager with(@NonNull Context context) {
	return getRetriever(context).get(context);
}

private static RequestManagerRetriever getRetriever(@Nullable Context context) {
	return Glide.get(context).getRequestManagerRetriever();
}

public static Glide get(@NonNull Context context) {
	checkAndInitializeGlide(context);
}
private static void checkAndInitializeGlide(@NonNull Context context) {
	initializeGlide(context);
}

private static void initializeGlide(@NonNull Context context) {
	initializeGlide(context, new GlideBuilder());
}
private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
	Context applicationContext = context.getApplicationContext();
	//1.è·å–æ³¨è§£è‡ªåŠ¨ç”Ÿæˆçš„AppGlideModule
	GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
	List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
	if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
	  //è¿™é‡Œè§£æmanifestä¸­çš„ï¼Œmetedataå­—æ®µï¼Œå¹¶æ·»åŠ åˆ°listçš„æ ¼å¼çš„manifestModulesä¸­
	  manifestModules = new ManifestParser(applicationContext).parse();
	}
...
	RequestManagerRetriever.RequestManagerFactory factory =
		annotationGeneratedModule != null
			? annotationGeneratedModule.getRequestManagerFactory() : null;
	//ç»™builderè®¾ç½®ä¸€ä¸ªRequestManagerFactoryï¼Œç”¨äºåˆ›å»ºRequestManager
	builder.setRequestManagerFactory(factory);
	for (com.bumptech.glide.module.GlideModule module : manifestModules) {
	  module.applyOptions(applicationContext, builder);
	}
	if (annotationGeneratedModule != null) {
	  annotationGeneratedModule.applyOptions(applicationContext, builder);
	}
	//åˆ›å»ºGlideå¯¹è±¡  --å…³æ³¨ç‚¹1--
	Glide glide = builder.build(applicationContext);
	//è¿™é‡Œç»™manifestModulesä¸­è®¾ç½®çš„GlideModuleæ³¨å†Œåˆ°åº”ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸­
	for (com.bumptech.glide.module.GlideModule module : manifestModules) {
	  module.registerComponents(applicationContext, glide, glide.registry);
	}
	//å°†åº”ç”¨çš„applicationContextå’Œbuildåˆ›å»ºçš„glideæ³¨å†Œåˆ°ï¼š
	//ä¹‹å‰ä½¿ç”¨æ³¨è§£@GlideModuleåˆ›å»ºçš„GlideAppä¸­ï¼Œå¯ä»¥è®©GlideAppåœ¨é€€å‡ºæ—¶ï¼Œå¯ä»¥å¯¹glideæˆ–è€…appåšä¸€äº›å¤„ç†
	if (annotationGeneratedModule != null) {
	  annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
	}
	//è¿™é‡Œå°†glideæ³¨å†Œåˆ°åº”ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸­ï¼š
	//glideå®ç°äº†ComponentCallbacksæ¥å£ï¼Œè¿™ä¸ªæ¥å£æœ‰ä¸¤ä¸ªæ–¹æ³•onConfigurationChangedå’ŒonLowMemoryï¼Œ
	//åœ¨åº”ç”¨å›è°ƒè¿™ä¸¤ä¸ªæ¥å£çš„æ—¶å€™ï¼Œglideå¯ä»¥æ„ŸçŸ¥åˆ°ï¼Œå¯ä»¥å¯¹ç¼“å­˜æˆ–è€…å›¾ç‰‡åšä¸€äº›å¤„ç†ç­‰
	applicationContext.registerComponentCallbacks(glide);
	Glide.glide = glide;
}

```

`--å…³æ³¨ç‚¹1--`

```java
Glide build(@NonNull Context context) {
	//åˆ›å»ºSourceExecutorçº¿ç¨‹æ± 
    if (sourceExecutor == null) {
      sourceExecutor = GlideExecutor.newSourceExecutor();
    }
	//åˆ›å»ºdiskCacheExecutorç£ç›˜ç¼“å­˜çº¿ç¨‹æ± 
    if (diskCacheExecutor == null) {
      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
    }
	//åˆ›å»ºanimationExecutoråŠ¨ç”»çº¿ç¨‹æ± 
    if (animationExecutor == null) {
      animationExecutor = GlideExecutor.newAnimationExecutor();
    }
	//åˆ›å»ºå†…å­˜å¤§å°æµ‹é‡å™¨ï¼ŒåæœŸä¼šæ ¹æ®è¿™ä¸ªæµ‹é‡å™¨æµ‹å‡ºçš„å†…å­˜çŠ¶æ€ï¼Œå¯¹ç¼“å­˜è¿›è¡Œæ“ä½œ
    if (memorySizeCalculator == null) {
      memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
    }
	//è¿™ä¸ªç±»é‡Œé¢å¯¹Activityæˆ–è€…Fragmentçš„ç”Ÿå‘½å‘¨æœŸåšäº†ç›‘å¬ï¼Œåœ¨Activityæˆ–è€…Fragmentå¤„äºæ´»è·ƒçŠ¶æ€æ—¶å»ç›‘å¬ç½‘ç»œè¿æ¥çŠ¶æ€ï¼Œåœ¨ç›‘å¬ä¸­åšä¸€äº›é‡å¯ç­‰æ“ä½œ
    if (connectivityMonitorFactory == null) {
      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
    }
	//åˆ›å»ºä¸€ä¸ªBitMapçš„ç¼“å­˜æ± ï¼Œå†…éƒ¨FIFO
    if (bitmapPool == null) {
      int size = memorySizeCalculator.getBitmapPoolSize();
      if (size > 0) {
        bitmapPool = new LruBitmapPool(size);
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
    }
	//åˆ›å»ºä¸€ä¸ªç¼“å­˜æ± åˆ—è¡¨
    if (arrayPool == null) {
      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
    }
	//åˆ›å»ºä¸€ä¸ªResourceç¼“å­˜æ± 
    if (memoryCache == null) {
      memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
    }
	//åˆ›å»ºç£ç›˜ç¼“å­˜æ± 
    if (diskCacheFactory == null) {
      diskCacheFactory = new InternalCacheDiskCacheFactory(context);
    }
	//å°†ä¸Šé¢åˆ›å»ºçš„æ‰€æœ‰å¯¹è±¡å°è£…åˆ°ä¸€ä¸ªEngineå¯¹è±¡ä¸­ï¼Œä»¥åæ‰€æœ‰éœ€è¦çš„ç¼“å†²æ± æˆ–è€…çº¿ç¨‹æ± éƒ½åœ¨è¿™é‡Œé¢è·å–å³å¯
    if (engine == null) {
      engine =
          new Engine(
              memoryCache,
              diskCacheFactory,
              diskCacheExecutor,
              sourceExecutor,
              GlideExecutor.newUnlimitedSourceExecutor(),
              animationExecutor,
              isActiveResourceRetentionAllowed);
    }
	//è¿™é‡Œæ˜¯å›è°ƒåˆ—è¡¨ï¼Œç”¨æˆ·è®¾ç½®çš„Listeneræœ‰å¯èƒ½ä¼šæœ‰å¤šä¸ª
    if (defaultRequestListeners == null) {
      defaultRequestListeners = Collections.emptyList();
    } else {
      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
    }
	//è¿™é‡Œæ˜¯è®¾ç½®ä¸€äº›Glideçš„å®éªŒæ€§æ•°æ®ï¼Œè¿™é‡Œä¸ç”¨å¤ªè¿‡å…³æ³¨
    GlideExperiments experiments = glideExperimentsBuilder.build();
    RequestManagerRetriever requestManagerRetriever =
        new RequestManagerRetriever(requestManagerFactory, experiments);
	//æœ€åå°†ä¸Šé¢åˆ›å»ºçš„æ‰€æœ‰å¯¹è±¡éƒ½ä¿å­˜åˆ°ä¸€ä¸ªGlideå¯¹è±¡ä¸­ï¼Œå¹¶è¿”å›
    return new Glide(
        context,
        engine,
        memoryCache,
        bitmapPool,
        arrayPool,
        requestManagerRetriever,
        connectivityMonitorFactory,
        logLevel,
        defaultRequestOptionsFactory,
        defaultTransitionOptions,
        defaultRequestListeners,
        experiments);
}
```

çœ‹Glideæ„é€ æ–¹æ³•ï¼š


```java
Glide(...){
	1.åˆ›å»ºäº†ä¸€ä¸ªRegistryï¼Œè¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯ç”¨æ¥æ³¨å†ŒmodelClasså’ŒdataClasså’Œfactoryå¯¹åº”ï¼Œç”±æ­¤å¯ä»¥é€šè¿‡modelClassæ‰¾åˆ°å¯¹åº”çš„dataClasså’Œfactory
	registry = new Registry();
    registry.register(new DefaultImageHeaderParser());
	
	registry
        .append(ByteBuffer.class, new ByteBufferEncoder())
        .append(InputStream.class, new StreamEncoder(arrayPool))
		...
		//è¿™é‡Œæ˜¯ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„ï¼Œæ ‡æ³¨TODO1ã€‚åé¢è°ƒç”¨DataFetchä¼šç”¨åˆ°è¿™ä¸ªæ³¨å†Œçš„factory 
		.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
		..
	//è¿™é‡Œçœç•¥äº†å¾ˆå¤šappendè°ƒç”¨ï¼š
}
```




å›åˆ°è°ƒç”¨ â€œ`å…³æ³¨ç‚¹1`â€çš„ä»£ç å¤„
`initializeGlide`æ–¹æ³•è®²è§£å®Œåï¼Œæˆ‘ä»¬å›è°ƒæœ€å¼€å§‹çš„`with`è°ƒç”¨æ–¹æ³•å¤„ï¼š

```java
public static RequestManager with(@NonNull Context context) {
	return getRetriever(context).get(context);
}
è¿™é‡Œæœ‰ä¸ªgetæ–¹æ³•ï¼šæˆ‘ä»¬è¿›å…¥çœ‹çœ‹
public RequestManager get(@NonNull Context context) {
	//ä¼ å…¥çš„contextä¸èƒ½ä¸ºnull
    if (context == null) {
      throw new IllegalArgumentException("You cannot start a load on a null Context");
    } else if (Util.isOnMainThread() && !(context instanceof Application)) {
      if (context instanceof FragmentActivity) {
        return get((FragmentActivity) context);
      } else if (context instanceof Activity) {
        return get((Activity) context);
      } else if (context instanceof ContextWrapper
          // Only unwrap a ContextWrapper if the baseContext has a non-null application context.
          // Context#createPackageContext may return a Context without an Application instance,
          // in which case a ContextWrapper may be used to attach one.
          && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {
        return get(((ContextWrapper) context).getBaseContext());
      }
    }
    return getApplicationManager(context);	
}
```

è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°ï¼š

- **1**.å¦‚æœ`woth`æ–¹æ³•åœ¨`å­çº¿ç¨‹`è¿è¡Œï¼Œåˆ™ä¼šèµ°åˆ°`getApplicationManager(context`)ï¼Œè¿™é‡Œä¼šåˆ›å»ºä¸€ä¸ª`å…¨å±€çš„Glide`ï¼Œä¸ä¼šéšç€æ§ä»¶`ç”Ÿå‘½å‘¨æœŸ`é”€æ¯
- **2**.å¦‚æœæ˜¯`ä¸»çº¿ç¨‹`ï¼š
	- **2.1**ï¼šcontextæ˜¯`FragmentActivity`ï¼Œè¿”å›ä¸€ä¸ªFragmentçš„ç”Ÿå‘½å‘¨æœŸçš„Glide RequestManager
	- **2.2**ï¼šcontextæ˜¯`Activity`ï¼Œè¿”å›ä¸€ä¸ªActivityçš„ç”Ÿå‘½å‘¨æœŸçš„Glide RequestManager
	- **2.3**ï¼šcontextæ˜¯`ContextWrapper`ï¼Œè¿”å›ä¸€ä¸ªContextWrapperçš„ç”Ÿå‘½å‘¨æœŸçš„Glide RequestManager
- 3.å…¶ä»–æƒ…å†µå°±è¿”å›åº”ç”¨å±‚çš„**RequestManager**ï¼Œ

`æ³¨æ„`ï¼š
> æ‰€ä»¥åœ¨å­çº¿ç¨‹ä¸­åˆ›å»ºçš„RequestManageréƒ½æ˜¯å…¨å±€åº”ç”¨çš„RequestManagerï¼Œåªèƒ½æ„ŸçŸ¥åº”ç”¨çŠ¶æ€ï¼Œæ— æ³•æ„ŸçŸ¥æ§ä»¶çŠ¶æ€

â€‹		

æ€»ç»“withæ–¹æ³•ï¼š
> ä½œç”¨ï¼šåˆå§‹åŒ–`glide`ï¼šåˆ›å»ºäº†å¤šç§`çº¿ç¨‹æ± `ï¼Œå¤šç§`ç¼“å­˜æ± `ï¼Œå°†glideæ³¨å†Œåˆ°åº”ç”¨æ§ä»¶çš„`ç”Ÿå‘½å‘¨æœŸ`ä¸­ï¼Œå¯ä»¥æ„ŸçŸ¥åº”ç”¨çš„å†…å­˜çŠ¶æ€ä»¥åŠç•Œé¢é…ç½®ç­‰ä¿¡æ¯
>
> è¿”å›å€¼ï¼š`RequestManager`


### æ­¥éª¤2ï¼šload

```java
public RequestBuilder<Drawable> load(@Nullable String string) {
   return asDrawable().load(string);
}
public RequestBuilder<Drawable> asDrawable() {
    return as(Drawable.class);
}
public <ResourceType> RequestBuilder<ResourceType> as(
	@NonNull Class<ResourceType> resourceClass) {
	return new RequestBuilder<>(glide, this, resourceClass, context);
}
```

- çœ‹åˆ°`asDrawable`å…¶å®å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ª`RequestBuilder`

æ¥çœ‹`RequestBuilder`çš„`load`æ–¹æ³•ï¼š

```java
public RequestBuilder<TranscodeType> load(@Nullable String string) {
    return loadGeneric(string);
}
private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
	//è¿™ä¸ªåˆ¤æ–­é»˜è®¤ä¸ºfalse
	if (isAutoCloneEnabled()) {
	  return clone().loadGeneric(model);
	}
	this.model = model;
	isModelSet = true;
	return selfOrThrowIfLocked();
}
```

`load`æ–¹æ³•å¾ˆç®€å•ï¼š
> å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ª`RequestBuilder`ï¼Œå¹¶è®¾ç½®äº†è¯·æ±‚çš„`url`ä¿¡æ¯

### æ­¥éª¤3ï¼šinto

**è¿™é‡Œæ‰æ˜¯glideçš„é‡ç‚¹**

å‰é¢ä¸¤ä¸ªæ­¥éª¤éƒ½æ˜¯åˆå§‹åŒ–æ“ä½œ
æˆ‘ä»¬å°†intoæ–¹æ³•åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼š
- `decodeJobå‰`
- `decodeJobå¼€å§‹`
- `decodeJobç»“æŸ`


#### `é˜¶æ®µ1`ï¼šdecodeJobå‰

```java
public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
	//å…ˆæ–­è¨€æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸Šï¼Œå¦‚æœæ˜¯å­çº¿ç¨‹åˆ™æŠ›å¼‚å¸¸é€€å‡ºï¼Œ
	//è¿™å°±è¯å¯ä»¥çœ‹å‡ºglideå¯ä»¥åœ¨å­çº¿ç¨‹åˆå§‹åŒ–ï¼Œä½†æ˜¯intoæ“ä½œä¸€å®šéœ€è¦åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ
	Util.assertMainThread();
	//ä¼ å…¥çš„viewä¸èƒ½ä¸ºnullï¼Œå¦åˆ™ä¼šæŠ›å¼‚å¸¸
	Preconditions.checkNotNull(view);

	BaseRequestOptions<?> requestOptions = this;
	//è¿™é‡Œæ˜¯è®¾ç½®viewçš„scaleTypeï¼Œglideé»˜è®¤æä¾›äº†å››ç§scaleType
	if (!requestOptions.isTransformationSet()
		&& requestOptions.isTransformationAllowed()
		&& view.getScaleType() != null) {
	  // Clone in this method so that if we use this RequestBuilder to load into a View and then
	  // into a different target, we don't retain the transformation applied based on the previous
	  // View's scale type.
	  switch (view.getScaleType()) {
		case CENTER_CROP:
		  requestOptions = requestOptions.clone().optionalCenterCrop();
		  break;
		case CENTER_INSIDE:
		  requestOptions = requestOptions.clone().optionalCenterInside();
		  break;
		case FIT_CENTER:
		case FIT_START:
		case FIT_END:
			//é»˜è®¤æ˜¯ä½¿ç”¨è¿™ä¸ªçŠ¶æ€è®¾ç½®å›¾ç‰‡
		  requestOptions = requestOptions.clone().optionalFitCenter();
		  break;
		case FIT_XY:
		  requestOptions = requestOptions.clone().optionalCenterInside();
		  break;
		case CENTER:
		case MATRIX:
		default:
		  // Do nothing.
	  }
	}
	return into(
        glideContext.buildImageViewTarget(view, transcodeClass), //Â·å…³æ³¨ç‚¹2Â·
        /*targetListener=*/ null,
        requestOptions,
        Executors.mainThreadExecutor());
}
```

æ¥çœ‹Â·`å…³æ³¨ç‚¹2`Â·

```java
public <X> ViewTarget<ImageView, X> buildImageViewTarget(
	@NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
	return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
}
public class ImageViewTargetFactory {
	@NonNull
	@SuppressWarnings("unchecked")
	public <Z> ViewTarget<ImageView, Z> buildTarget(
	  @NonNull ImageView view, @NonNull Class<Z> clazz) {
	if (Bitmap.class.equals(clazz)) {
	  return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
	} else if (Drawable.class.isAssignableFrom(clazz)) {
	  return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
	} else {
	    throw new IllegalArgumentException(
		  "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
		}
	}
}
```

å¯ä»¥çœ‹åˆ°
- ä¼ å…¥çš„æ˜¯`Bitmap`.class.åˆ™åˆ›å»º`BitmapImageViewTarget`
- å¦‚æœæ˜¯`Drawable`.classï¼Œåˆ™åˆ›å»º`DrawableImageViewTarget`

å¹¶å°†ä¼ å…¥çš„`ImageView`åŒ…è£¹è¿›

> æ­¥éª¤2 loadæ–¹æ³•ä¸­æœ‰äº†è§£è¿‡ï¼Œloadæ–¹æ³•é»˜è®¤è°ƒç”¨äº†asDrawableï¼Œæ‰€ä»¥è¿”å›çš„æ˜¯Drawableç±»å‹çš„æ•°æ®ï¼Œ
> è¿™é‡Œå¦‚æœéœ€è¦æ‹¿åˆ°çš„æ˜¯Bitmapçš„ç±»å‹å›¾ç‰‡æ•°æ®ï¼Œåˆ™éœ€è¦è°ƒç”¨asBitmapï¼Œè·³è¿‡é»˜è®¤asDrawableæ–¹æ³•çš„æ‰§è¡Œ

ç»§ç»­å›åˆ°`å…³æ³¨ç‚¹2è°ƒç”¨`çš„åœ°æ–¹ï¼šè°ƒç”¨äº†ä¸€ä¸ªå†…éƒ¨çš„`into`æ–¹æ³•

```java
private <Y extends Target<TranscodeType>> Y into(
	  @NonNull Y target,
	  @Nullable RequestListener<TranscodeType> targetListener,
	  BaseRequestOptions<?> options,
	  Executor callbackExecutor) {
	...
	//å…³æ³¨ç‚¹3
	Request request = buildRequest(target, targetListener, options, callbackExecutor);

	Request previous = target.getRequest();
	if (request.isEquivalentTo(previous)
		&& !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
	  // If the request is completed, beginning again will ensure the result is re-delivered,
	  // triggering RequestListeners and Targets. If the request is failed, beginning again will
	  // restart the request, giving it another chance to complete. If the request is already
	  // running, we can let it continue running without interruption.
	  if (!Preconditions.checkNotNull(previous).isRunning()) {
		// Use the previous request rather than the new one to allow for optimizations like skipping
		// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
		// that are done in the individual Request.
		previous.begin();
	  }
	  return target;
	}

	requestManager.clear(target);
	target.setRequest(request);
	requestManager.track(target, request);

	return target;
}
```

æ¥çœ‹`å…³æ³¨ç‚¹3`ï¼š

```java
private Request buildRequest(
	  Target<TranscodeType> target,
	  @Nullable RequestListener<TranscodeType> targetListener,
	  BaseRequestOptions<?> requestOptions,
	  Executor callbackExecutor) {
	return buildRequestRecursive(
		/*requestLock=*/ new Object(),
		target,
		targetListener,
		/*parentCoordinator=*/ null,
		transitionOptions,
		requestOptions.getPriority(),
		requestOptions.getOverrideWidth(),
		requestOptions.getOverrideHeight(),
		requestOptions,
		callbackExecutor);
}
```

ç»§ç»­çœ‹buildRequestRecursive
ä¸ºäº†ä¸è®©å¤§å®¶çœ‹çš„å¤´æ™•ï¼Œéå…³é”®ä»£ç æˆ‘è¿™è¾¹çœç•¥äº†ï¼š

```java
private Request buildRequestRecursive(...) {

    ...
	//è¿™é‡Œåˆ›å»ºä¸€ä¸ªç¼©ç•¥å›¾çš„è¯·æ±‚ï¼šå…³æ³¨ç‚¹4
    Request mainRequest =
        buildThumbnailRequestRecursive(
            requestLock,
            target,
            targetListener,
            parentCoordinator,
            transitionOptions,
            priority,
            overrideWidth,
            overrideHeight,
            requestOptions,
            callbackExecutor);
	...
	//è¿™é‡Œåˆ›å»ºä¸€ä¸ªerrorRequestè¯·æ±‚
    Request errorRequest =
        errorBuilder.buildRequestRecursive(
            requestLock,
            target,
            targetListener,
            errorRequestCoordinator,
            errorBuilder.transitionOptions,
            errorBuilder.getPriority(),
            errorOverrideWidth,
            errorOverrideHeight,
            errorBuilder,
            callbackExecutor);
    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
    return errorRequestCoordinator;
  }
```


è¿›å…¥`å…³æ³¨ç‚¹4`


```java
private Request buildThumbnailRequestRecursive(...)
  {
	...
	if (thumbnailBuilder != null) {
		Request fullRequest = obtainRequest(...)
		...
		Request thumbRequest = thumbnailBuilder.buildRequestRecursive(...)
		coordinator.setRequests(fullRequest, thumbRequest);
		return coordinator;
	}else if(thumbSizeMultiplier != null){
		Request fullRequest = obtainRequest(...)
		Request thumbnailRequest = obtainRequest()
		coordinator.setRequests(fullRequest, thumbnailRequest);
		return coordinator;
	}else{
		return obtainRequest(
          requestLock,
          target,
          targetListener,
          requestOptions,
          parentCoordinator,
          transitionOptions,
          priority,
          overrideWidth,
          overrideHeight,
          callbackExecutor);
	}
	
  
  }
  
è¿›å…¥obtainRequestçœ‹çœ‹ï¼š

private Request obtainRequest(
	  Object requestLock,
	  Target<TranscodeType> target,
	  RequestListener<TranscodeType> targetListener,
	  BaseRequestOptions<?> requestOptions,
	  RequestCoordinator requestCoordinator,
	  TransitionOptions<?, ? super TranscodeType> transitionOptions,
	  Priority priority,
	  int overrideWidth,
	  int overrideHeight,
	  Executor callbackExecutor) {
	return SingleRequest.obtain(
		context,
		glideContext,
		requestLock,
		model,
		transcodeClass,
		requestOptions,
		overrideWidth,
		overrideHeight,
		priority,
		target,
		targetListener,
		requestListeners,
		requestCoordinator,
		glideContext.getEngine(),
		transitionOptions.getTransitionFactory(),
		callbackExecutor);
	}
}
```
- è¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ª`SingleRequest`çš„è¯·æ±‚ç±»ï¼Œå…ˆè®°ä½è¿™é‡Œ

æ€»ç»“ä¸‹å…³æ³¨ç‚¹3ï¼š`buildRequest`

> å¦‚æœæœ‰è¦æ±‚åŠ è½½ç¼©ç•¥å›¾è¯·æ±‚çš„ï¼Œä¼šå°†ç¼©ç•¥å›¾è¯·æ±‚å’Œå›¾ç‰‡çœŸå®è¯·æ±‚æ”¾åˆ°ä¸€èµ·ã€‚
> å¦‚æœæ²¡æœ‰ç¼©ç•¥å›¾è¯·æ±‚ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªSingleRequestçš„è¯·æ±‚è¿”å›ç»™è°ƒç”¨æµ‹

æˆ‘ä»¬å›è°ƒ`å…³æ³¨ç‚¹3`è¢«è°ƒç”¨å¤„ï¼šè¿™é‡Œæˆ‘å°†å‰é¢ä»£ç å†æ¬¡æ‹·è´ä¸€æ¬¡å¤§å®¶å°±ä¸ç”¨å†æ¬¡å‘å‰ç¿»æ‰¾äº†ã€‚

```java
private <Y extends Target<TranscodeType>> Y into(
	  @NonNull Y target,
	  @Nullable RequestListener<TranscodeType> targetListener,
	  BaseRequestOptions<?> options,
	  Executor callbackExecutor) {
	...
	//å…³æ³¨ç‚¹3
	Request request = buildRequest(target, targetListener, options, callbackExecutor);
	
	
	Request previous = target.getRequest();
	//è¿™é‡Œåˆ¤æ–­å½“å‰åˆ›å»ºçš„è¯·æ±‚å’Œå‰é¢çš„è¯·æ±‚æ˜¯å¦æ˜¯åŒä¸€ä¸ªè¯·æ±‚ï¼Œæˆ‘ä»¬çœ‹ä¸åŒçš„æƒ…å†µï¼Œæ‰€ä»¥è·³è¿‡è¿™é‡Œ
	if (request.isEquivalentTo(previous)
		&& !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
	  // If the request is completed, beginning again will ensure the result is re-delivered,
	  // triggering RequestListeners and Targets. If the request is failed, beginning again will
	  // restart the request, giving it another chance to complete. If the request is already
	  // running, we can let it continue running without interruption.
	  if (!Preconditions.checkNotNull(previous).isRunning()) {
		// Use the previous request rather than the new one to allow for optimizations like skipping
		// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
		// that are done in the individual Request.
		previous.begin();
	  }
	  return target;
	}
	//è¯·æ±‚å‰å…ˆè°ƒç”¨clearä¸€ä¸‹è¿™ä¸ªtarget
	requestManager.clear(target);
	target.setRequest(request);
	//è¿™é‡Œæ˜¯çœŸå®è¯·æ±‚å…¥å£ æˆ‘ä»¬è¿›å»çœ‹çœ‹
	requestManager.track(target, request);

	return target;
}
trackæ–¹æ³•:
synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
	//è¿™é‡Œå°†targetæ”¾å…¥ä¸€ä¸ªtargetsé›†åˆä¸­
	targetTracker.track(target);
	//è¯·æ±‚å…¥å£
	requestTracker.runRequest(request);
}
runRequestæ–¹æ³•ï¼š
public void runRequest(@NonNull Request request) {
    requests.add(request);
	//å¦‚æœä¸æ˜¯æš‚åœçŠ¶æ€ï¼Œåˆ™è°ƒç”¨beginå¯åŠ¨è¯·æ±‚ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å°†requestæ”¾å…¥pendingRequestsï¼Œå»¶è¿Ÿå¯åŠ¨ï¼Œ
    if (!isPaused) {
      request.begin();
    } else {
      request.clear();
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Paused, delaying request");
      }
      pendingRequests.add(request);
    }
}

```

è¿›å…¥`begin`ï¼š

åœ¨è®²è§£`SingleRequest`å‰ï¼Œæˆ‘ä»¬ä¸‹æ¥äº†è§£ä¸‹ä¸€ä¸ª`Request`çš„å‡ ç§çŠ¶æ€ï¼š

```java
private enum Status {
    /** Created but not yet running. */
    PENDING,
    /** In the process of fetching media. */
    RUNNING,
    /** Waiting for a callback given to the Target to be called to determine target dimensions. */
    WAITING_FOR_SIZE,
    /** Finished loading media successfully. */
    COMPLETE,
    /** Failed to load media, may be restarted. */
    FAILED,
    /** Cleared by the user with a placeholder set, may be restarted. */
    CLEARED,
}
```

è¿™ä¸ª`Status`æ˜¯`SingleRequest`çš„ä¸€ä¸ªå†…éƒ¨æšä¸¾ç±»ï¼š
- `PENDING`ï¼šæŒ‚èµ·çŠ¶æ€ï¼Œè¿˜æœªè¿è¡Œï¼Œå¾…è¿è¡Œï¼Œå‰é¢æˆ‘ä»¬è¯´è¿‡å¦‚æœRequestå¤„äºisPausedçŠ¶æ€ï¼Œä¼šæ·»åŠ è¿›å…¥pendingRequestsçš„listä¸­ï¼Œè¿™ä¸ªé‡Œé¢çš„Requestå°±æ˜¯å¤„äºPENDINGçŠ¶æ€
- `RUNNING`ï¼šè¿™ä¸ªçŠ¶æ€çš„Requestæ­£åœ¨å»æœåŠ¡å™¨æ‹¿æ•°æ®é˜¶æ®µ
- `WAITING_FOR_SIZE`ï¼šç­‰å¾…è·å–ImageViewçš„ä¸€ä¸ªå°ºå¯¸é˜¶æ®µ
- `COMPLETE`ï¼šæˆåŠŸæ‹¿åˆ°è¯·æ±‚æ•°æ®
- `FAILED`ï¼šæ²¡æœ‰è·å–åˆ°è¯·æ±‚æ•°æ®ï¼Œåœ¨ä¸€å®šæƒ…å†µä¸‹ä¼šé‡å¯ï¼Œä¾‹å¦‚ï¼šåœ¨ç½‘ç»œçŠ¶æ€è‰¯å¥½çš„æ—¶å€™ï¼ŒGlideä¼šè‡ªåŠ¨é‡å¯è¯·æ±‚ï¼Œå»è·å–æ•°æ®ï¼Œå› ä¸ºGlideæ³¨å†Œäº†ç½‘ç»œçŠ¶æ€çš„ç›‘å¬
- `CLEARED`ï¼šè¢«ç”¨æˆ·æ¸…ç†çŠ¶æ€ï¼Œä½¿ç”¨ä¸€ä¸ªplaceholderä»£æ›¿æ•°æ®å…ƒï¼Œåœ¨ä¸€å®šæƒ…å†µä¸‹ä¼šé‡å¯Request

å¥½äº†ï¼Œæœ‰äº†ä¸Šé¢çš„åŸºç¡€æˆ‘ä»¬å†æ¥çœ‹ä¸‹é¢ä»£ç ï¼š

è¿™ä¸ª`request`æ˜¯åœ¨`å…³æ³¨ç‚¹3`å¤„åˆ›å»ºçš„`SingleRequest`

```java
public void begin() {
    synchronized (requestLock) {
      ...
	  //è¯·æ±‚å¤„äºRUNNINGçŠ¶æ€ï¼Œè¿™ä¸ªå¼‚å¸¸ä¼šè¢«ä¸¢å¼ƒ
      if (status == Status.RUNNING) {
        throw new IllegalArgumentException("Cannot restart a running request");
      }
	  ...
	  //è¯·æ±‚å¤„äºCOMPLETEï¼Œåˆ™å›è°ƒonResourceReadyï¼Œè®©åº”ç”¨å»å†…å­˜ä¸­è·å–ï¼Œè¿™é‡Œçš„DataSource.MEMORY_CACHEï¼šæ ‡å¿—æ•°æ®å…ƒåœ¨å†…å­˜ç¼“å­˜ä¸­
      if (status == Status.COMPLETE) {
        onResourceReady(
            resource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);
        return;
      }
	  ...
		
      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
		//è¿™é‡Œæ˜¯è¯·æ±‚å…¥å£
        onSizeReady(overrideWidth, overrideHeight);
      } else {
        target.getSize(this);
      }
      if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
          && canNotifyStatusChanged()) {
        target.onLoadStarted(getPlaceholderDrawable());
      }
		
    }
}
```

ä»`begin`æ–¹æ³•ä¸­ï¼Œçœ‹åˆ°å¯¹è¯·æ±‚çš„çŠ¶æ€åšäº†åˆ¤æ–­ï¼Œåªæœ‰æ˜¯æœªå¤„ç†çš„è¯·æ±‚æ‰ä¼šå»è¯·æ±‚æ•°æ®ï¼Œå…¶ä»–æƒ…å†µæ ¹æ®å…·ä½“çŠ¶æ€å¤„ç†

æˆ‘ä»¬è¿›å…¥`onSizeReady`çœ‹çœ‹ï¼š

```java
public void onSizeReady(int width, int height) {
	...
	loadStatus = engine.load(...)
	...
}
public <R> LoadStatus load(...){
	EngineResource<?> memoryResource;
    synchronized (this) {
	  //å»ç¼“å­˜æ± ä¸­è·å–æ•°æ® ï¼Œè¿™é‡Œé¢å†…éƒ¨å…ˆå»æ´»åŠ¨çš„ç¼“å­˜ä¸­activeResourcesè·å–å›¾ç‰‡æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰è·å–åˆ°å°±å»ç¼“å­˜æ± cacheä¸­è·å–ï¼Œéƒ½æ˜¯é€šè¿‡å¯¹åº”çš„keyè·å–
      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);
	  //æ²¡æœ‰å–åˆ°ç¼“å­˜æ•°æ®ï¼Œåˆ™è¿›å…¥waitForExistingOrStartNewJobï¼Œçœ‹åå­—åº”è¯¥æ˜¯å»è¯·æ±‚æ•°æ®çš„æ–¹æ³•ï¼Œæˆ‘ä»¬è¿›å…¥è¿™é‡Œé¢çœ‹çœ‹
      if (memoryResource == null) {
        return waitForExistingOrStartNewJob(
            glideContext,
            model,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            options,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache,
            cb,
            callbackExecutor,
            key,
            startTime);
      }
    }

    // Avoid calling back while holding the engine lock, doing so makes it easier for callers to
    // deadlock.
    cb.onResourceReady(
        memoryResource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);
    return null;

}

private <R> LoadStatus waitForExistingOrStartNewJob(
	...
	//è¿™é‡Œåˆ›å»ºä¸€ä¸ªEngineJob
	EngineJob<R> engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);
	//è¿™é‡Œåˆ›å»ºä¸€ä¸ªdecodeJob
    DecodeJob<R> decodeJob =
        decodeJobFactory.build(
            glideContext,
            model,
            key,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            onlyRetrieveFromCache,
            options,
            engineJob);
	//å°†engineJobæ”¾å…¥jobsä¸­
    jobs.put(key, engineJob);
	//ç»™engineJobæ·»åŠ å›è°ƒå’Œçº¿ç¨‹æ± æ‰§è¡Œå™¨
    engineJob.addCallback(cb, callbackExecutor);
	//å¯åŠ¨engineJobï¼Œå¹¶ä¼ å…¥decodeJob
    engineJob.start(decodeJob);

    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey("Started new load", startTime, key);
    }
    return new LoadStatus(cb, engineJob)

}
```

è¿›å…¥`engineJob.start(decodeJob)`æ–¹æ³•çœ‹çœ‹ï¼š

```java
public synchronized void start(DecodeJob<R> decodeJob) {
	this.decodeJob = decodeJob;
	GlideExecutor executor =
		decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();
	executor.execute(decodeJob);
}
```

- å†…éƒ¨å…¶å®å°±æ˜¯ä½¿ç”¨çº¿ç¨‹æ± å»è¯·æ±‚`decodeJob`ï¼š

- æ‰§è¡Œ`decodeJob`å‰ï¼Œæˆ‘ä»¬å…ˆæ¥æ¢³ç†ä¸‹æˆ‘ä»¬é˜¶æ®µ1åˆ†æçš„æµç¨‹


```java
RequestBuilder.java
into{
	1.å¯¹ScaleTypeçš„RequestOptionåšå¤„ç†
	2.è°ƒç”¨å†…éƒ¨intoæ–¹æ³•æ‰§è¡Œ
	into(å‚æ•°1ï¼šDrawableImageViewTarget(view),å‚æ•°2ï¼šrequestOptions,å‚æ•°3ï¼šä¸»çº¿ç¨‹æ‰§è¡Œå™¨);
	{	
		1.åˆ›å»ºRequestï¼šbuildRequestï¼Œè¿”å›å€¼ï¼šSingleRequestå¯¹è±¡
		2.æ£€æŸ¥æ˜¯å¦å’Œå‰ä¸€ä¸ªè¯·æ±‚æ˜¯åŒä¸€ä¸ªï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç›´æ¥ä½¿ç”¨å‰ä¸€ä¸ªè¯·æ±‚å‘é€beginæ–¹æ³•ï¼Œå¦å°±èµ°ç¬¬3æ­¥
		3.æ¸…é™¤å½“å‰targetè¯·æ±‚;
		4.è¿›å…¥requestManager.track(target, request):
		  track{
			  1.è°ƒç”¨requestTracker.runRequest(request)ï¼š
			  runRequest{
				//å¦‚æœä¸æ˜¯æš‚åœçŠ¶æ€ï¼Œåˆ™è°ƒç”¨beginå¯åŠ¨è¯·æ±‚ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å°†requestæ”¾å…¥pendingRequestsï¼Œå»¶è¿Ÿå¯åŠ¨ï¼Œ
				1.request.begin():è¿™ä¸ªrequestæ˜¯ä¸€ä¸ªSingleRequestå¯¹è±¡
				begin{
					1.å¯¹è¯·æ±‚çŠ¶æ€åšåˆ¤æ–­
					2.è°ƒç”¨onSizeReady
					onSizeReady{
						engine.load{
							1.å»ç¼“å­˜ä¸­è·å–æ•°æ®ï¼šloadFromMemory
							2.1ä¸­æ²¡æœ‰è·å–åˆ°ç¼“å­˜æ•°æ®ï¼Œåˆ™è°ƒç”¨waitForExistingOrStartNewJob
							waitForExistingOrStartNewJob{
								1.è¿™é‡Œé¢å¯åŠ¨//å¯åŠ¨engineJobï¼Œå¹¶ä¼ å…¥decodeJobï¼šengineJob.start(decodeJob)
								start{
									1.è°ƒç”¨çº¿ç¨‹æ± å¯åŠ¨decodeJob
								}
							}
							
						}
					}
				}			
			  }	  	  
		  }		
	}
}
```


#### é˜¶æ®µ2ï¼š`decodeJob`æ‰§è¡Œé˜¶æ®µ

åœ¨è®²è§£`decodeJob`æ‰§è¡Œé˜¶æ®µå‰æˆ‘ä»¬å…ˆæ¥äº†è§£ä¸‹`Job`çš„å‡ ç§çŠ¶æ€ï¼š

```java
/** Why we're being executed again. */
private enum RunReason {
	/** The first time we've been submitted. */
	INITIALIZE,
	/** We want to switch from the disk cache service to the source executor. */
	SWITCH_TO_SOURCE_SERVICE,
	/**
	 * We retrieved some data on a thread we don't own and want to switch back to our thread to
	 * process the data.
	 */
	DECODE_DATA,
}
```


è¿™ä¸ª`RunReason`çœ‹åå­—å°±çŸ¥é“ï¼šè¿™é‡Œæ˜¯è¡¨ç¤ºä½ å¯åŠ¨è¿™ä¸ªJobæ˜¯è¦åšä»€ä¹ˆçš„ï¼Œä¸»è¦æœ‰ä¸‰ç§çŠ¶æ€ï¼š

- `INITIALIZE`ï¼š
å°±æ˜¯ä¸€ä¸ªæ–°çš„è¯·æ±‚å¿…é¡»ç»è¿‡çš„ç¬¬ä¸€æ­¥ï¼Œè¿™é‡Œjobä¸»è¦ä»»åŠ¡æ˜¯å»ç¼“å­˜ä¸­å–æ•°æ®

- `SWITCH_TO_SOURCE_SERVICE`ï¼š
å°±æ˜¯æˆ‘ä»¬å¸Œæœ›è¿™ä¸ªjobå®ç°ä»ç£ç›˜æœåŠ¡åˆ°èµ„æºè·å–é˜¶æ®µï¼Œ
è¿™ä¸ªæ€ä¹ˆç†è§£å‘¢ï¼Œäº†è§£OkHttpæºç éƒ½çŸ¥é“ï¼ŒOkHttpå†…éƒ¨ä½¿ç”¨çš„æ˜¯æ‹¦æˆªå™¨çš„æ¨¡å¼å¯¹è¯·æ±‚åšå¤„ç†ï¼Œæ¯ä¸ªè¯·æ±‚éƒ½éœ€è¦ç»è¿‡æ‹¦æˆªå™¨ä¾æ¬¡å¤„ç†ï¼Œæœ€åå¾—åˆ°è¯·æ±‚æ•°æ®ï¼Œ
å¦‚æœOkHttpå‘ç°ç¼“å­˜æ‹¦æˆªå™¨ä¸­æœ‰æ•°æ®ï¼Œåˆ™è¿”å›ï¼Œæ²¡æœ‰æ•°æ®ï¼Œåˆ™æ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨ã€‚
è¿™é‡Œä¹Ÿæ˜¯ä¸€æ ·ï¼Œæ¯ä¸ªjobç±»ä¼¼ä¸€ä¸ªæ‹¦æˆªå™¨ï¼Œæ¯æ¬¡éƒ½æ˜¯ä¼˜å…ˆå»ç¼“å­˜ä¸­è·å–æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ç¬¬ä¸€æ­¥çš„INITIALIZEçŠ¶æ€çš„jobï¼Œå¦‚æœæ²¡æœ‰æ•°æ®æ‰ä¼šå»ç½‘ç»œä¸­è¯·æ±‚ï¼Œ
SWITCH_TO_SOURCE_SERVICEå°±è¡¨ç¤ºæˆ‘ä»¬ç¼“å­˜ä¸­æ²¡æœ‰è·å–åˆ°æ•°æ®ï¼Œéœ€è¦å¯åŠ¨ä¸‹ä¸€ä¸ªjobå»ç½‘ç»œä¸­æ‹¿æ•°æ®ã€‚

- `DECODE_DATA`ï¼š
è¿™ä¸ªå¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯åœ¨å¼‚æ­¥çº¿ç¨‹ä¸Šè·å–åˆ°æ•°æ®ï¼Œå¸Œæœ›è·³è½¬åˆ°æˆ‘ä»¬è‡ªå·±çš„çº¿ç¨‹ä¸Šå»è§£ç æ•°æ®

è¿™é‡Œå†ä»‹ç»ä¸€ä¸ªå†…éƒ¨æšä¸¾ç±»ï¼š

```java
/** Where we're trying to decode data from. */
private enum Stage {
	/** The initial stage. */
	INITIALIZE,
	/** Decode from a cached resource. */
	RESOURCE_CACHE,
	/** Decode from cached source data. */
	DATA_CACHE,
	/** Decode from retrieved source. */
	SOURCE,
	/** Encoding transformed resources after a successful load. */
	ENCODE,
	/** No more viable stages. */
	FINISHED,
}
```

- è¿™ä¸ªç±»æ ‡è¯†æˆ‘ä»¬åº”è¯¥å»å“ªä¸ªç±»ä¸­æ‰§è¡Œå½“å‰`Job`ï¼š
æ¯ä¸ª`Job`éƒ½æœ‰å¯¹åº”çš„æ‰§è¡Œå™¨ï¼Œæ‰§è¡Œå®Œåï¼Œè°ƒç”¨`startNext`æ‰§è¡Œä¸‹ä¸€ä¸ª`Job`ï¼Œä¸‹ä¸€ä¸ªjobåˆæ˜¯å¯¹åº”å¦å¤–ä¸€ä¸ª`stage`çš„æ‰§è¡Œå™¨

ä¸»è¦æ˜¯åœ¨ä¸‹é¢ä¸€ä¸ªæ–¹æ³•ä¸­ä½¿ç”¨ï¼š

```java
private DataFetcherGenerator getNextGenerator() {
	switch (stage) {
	  case RESOURCE_CACHE:
		return new ResourceCacheGenerator(decodeHelper, this);
	  case DATA_CACHE:
		return new DataCacheGenerator(decodeHelper, this);
	  case SOURCE:
		return new SourceGenerator(decodeHelper, this);
	  case FINISHED:
		return null;
	  default:
		throw new IllegalStateException("Unrecognized stage: " + stage);
	}
}
```

- `RESOURCE_CACHE`ï¼šå¯¹åº”`ResourceCacheGenerator`æ‰§è¡Œå™¨
- `DATA_CACHE`ï¼šå¯¹åº”`DataCacheGenerator`æ‰§è¡Œå™¨
- `SOURCE`ï¼šå¯¹åº”`SourceGenerator`æ‰§è¡Œå™¨

ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“ï¼š
> ä½ å¯ä»¥æŠŠä¸€ä¸ªJobç†è§£ä¸ºä¸€ä¸ªæ‹¦æˆªå™¨ï¼Œæ¯æ¬¡éƒ½ä¼šæ ¹æ®å½“å‰Jobçš„çŠ¶æ€æ˜¯è¦ä¸åŒçš„æ‰§è¡Œå™¨å»æ‰§è¡Œä»»åŠ¡
- `ä»»åŠ¡æ€»çº¿`ï¼š

1.`ResourceCacheGenerator`:ç¼“å­˜ä¸­è·å–æ•°æ®ï¼Œè¿™ä¸ªæ•°æ®æ˜¯è¢«ä¿®æ”¹è¿‡çš„é™é‡‡æ ·ç¼“å­˜ 

2.`DataCacheGenerator`:ä¹Ÿæ˜¯ç¼“å­˜ä¸­è·å–æ•°æ®ï¼Œè¿™ä¸ªæ•°æ®æ˜¯æ²¡æœ‰è¢«ä¿®æ”¹çš„ç½‘è·¯è¯·æ±‚å…ƒæ•°æ®

3.`SourceGenerator`:è¿™ä¸ªæ‰§è¡Œå™¨æ‰§è¡Œçš„ä»»åŠ¡æ‰çœŸæ­£æ˜¯ç”¨äºç½‘ç»œè¯·æ±‚æ•°æ®

æ˜¯ä¸æ˜¯å’Œæˆ‘ä»¬çš„`OkHttp`å¾ˆåƒï¼Ÿ

æœ‰äº†ä¸Šé¢çš„åŸºç¡€æˆ‘ä»¬å†æ¥å¯¹`decodeJob`æºç è¿›è¡Œåˆ†æï¼š


DecodeJobç»§æ‰¿äº†Runnableæ¥å£ï¼Œæˆ‘ä»¬æ¥çœ‹ä»–çš„runæ–¹æ³•

```java
public void run() {
	...
	runWrapped();
	...
}
private void runWrapped() {
	switch (runReason) {
	  case INITIALIZE:
		//å…³æ³¨ç‚¹1
		stage = getNextStage(Stage.INITIALIZE);
		//å…³æ³¨ç‚¹2
		currentGenerator = getNextGenerator();
		//å…³æ³¨ç‚¹3
		runGenerators();
		break;
	  case SWITCH_TO_SOURCE_SERVICE:
		runGenerators();
		break;
	  case DECODE_DATA:
		decodeFromRetrievedData();
		break;
	  default:
		throw new IllegalStateException("Unrecognized run reason: " + runReason);
	}
}
```

`runWrapped`æ–¹æ³•ä¸­å¯¹`runReason`åšä¸€ä¸ªåˆ¤æ–­ï¼šåˆ†åˆ«æŒ‡å‘ä¸åŒçš„è¯·æ±‚ï¼š

//å…³æ³¨ç‚¹1
æˆ‘ä»¬çœ‹INITIALIZEï¼Œè°ƒç”¨äº†getNextStageä¼ å…¥Stage.INITIALIZE

```java
private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE
            : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE
            : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        // Skip loading from source if the user opted to only retrieve the resource from cache.
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException("Unrecognized stage: " + current);
    }
}
```

è¿™é‡Œé¢æ˜¯æ ¹æ®ä¼ å…¥çš„`diskCacheStrategy`ç£ç›˜ç¼“å­˜ç­–ç•¥å¯¹åº”ä¸åŒçš„çŠ¶æ€
æˆ‘ä»¬å‡è®¾`diskCacheStrategy`.`decodeCachedResource`()è¿”å›éƒ½æ˜¯`true`
åˆ™`next`å…³ç³»å¦‚ä¸‹ï¼š

```java
INITIALIZE->RESOURCE_CACHE->DATA_CACHE->SOURCE->FINISHED
```


å›åˆ°å‰é¢`runWrapped`æ–¹æ³•ï¼š

//å…³æ³¨ç‚¹2
getNextGeneratorè·å–æ‰§è¡Œå™¨å‰é¢å·²ç»è®²è¿‡ï¼Œæˆ‘ä»¬å†å‘ä¸‹å¯¹åº”å…³ç³»ï¼š

- `RESOURCE_CACHE`ï¼šå¯¹åº”`ResourceCacheGenerator`æ‰§è¡Œå™¨
- `DATA_CACHE`ï¼šå¯¹åº”`DataCacheGenerator`æ‰§è¡Œå™¨
- `SOURCE`ï¼šå¯¹åº”`SourceGenerator`æ‰§è¡Œå™¨

//å…³æ³¨ç‚¹3
è°ƒç”¨runGeneratorså¼€å§‹æ‰§è¡Œå¯¹åº”çš„job

```java
private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
    while (!isCancelled
        && currentGenerator != null
        && !(isStarted = currentGenerator.startNext())) {
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        reschedule();
        return;
      }
    }
}
```


> å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ‰ä¸ªwhileå¾ªç¯å°±æ˜¯æ ¹æ®å½“å‰stageçŠ¶æ€å¾ªç¯æ‰§è¡Œä¸åŒçš„è¯·æ±‚ï¼š

`æŒ‰å‰é¢æˆ‘ä»¬çš„åˆ†æ`ï¼š

ä¼˜å…ˆä¼šæ‰§è¡Œï¼š
`ResourceCacheGenerator` ï¼Œç„¶å`DataCacheGenerator`ï¼Œæœ€å`SourceGenerator`

ç¯‡å¹…é—®é¢˜ï¼šæˆ‘ä»¬è¿™åªå…·ä½“åˆ†æSourceGeneratorçš„æ–¹æ³•ï¼šå…¶ä»–ä¸¤ä¸ªæ‰§è¡Œå™¨å‰é¢å·²ç»ä»‹ç»è¿‡

```java
SourceGenerator.java
public boolean startNext() {
	...
    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      loadData = helper.getLoadData().get(loadDataListIndex++);
      if (loadData != null
          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
        started = true;
        startNextLoad(loadData);
      }
    }
	...
    return started;
}

çœ‹startNextLoadæ–¹æ³•ï¼š
private void startNextLoad(final LoadData<?> toStart) {
    loadData.fetcher.loadData(
        helper.getPriority(),
        new DataCallback<Object>() {
          @Override
          public void onDataReady(@Nullable Object data) {
            if (isCurrentRequest(toStart)) {
              onDataReadyInternal(toStart, data);
            }
          }

          @Override
          public void onLoadFailed(@NonNull Exception e) {
            if (isCurrentRequest(toStart)) {
              onLoadFailedInternal(toStart, e);
            }
          }
        });
}
```

è¿™ä¸ªfetcher = `MultiFetcher`å¯¹è±¡
è¿›å…¥MultiFetcherçš„`loadData`

```java
public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
	...
	fetchers.get(currentIndex).loadData(priority, this);
	...
}
```

`fetchers`æ˜¯ä¸€ä¸ª`List`ï¼Œå†…éƒ¨å­˜å‚¨çš„æ˜¯ä¸€ä¸ª`HttpUrlFeacher`
è¿™é‡Œä¼ å…¥äº†ä¸€ä¸ªthisä½œä¸ºcallbackå›è°ƒï¼Œåé¢ä¼šç”¨åˆ°ï¼šthis = MultiFetcher


```java
HttpUrlFeacher.java

public void loadData(
      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
	...
	try {
	  InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
	  callback.onDataReady(result);
	} catch (IOException e) {	  
	  callback.onLoadFailed(e);//å¼‚å¸¸å›è°ƒonLoadFailedæ¥å£ç»™åº”ç”¨å±‚
	} finally {
	  ...
	}
}
loadDataWithRedirectsæ–¹æ³•ï¼š
private InputStream loadDataWithRedirects(
      URL url, int redirects, URL lastUrl, Map<String, String> headers) throws HttpException {
    ...
	//å…³æ³¨ç‚¹1
    urlConnection = buildAndConfigureConnection(url, headers);

    try {
      // Connect explicitly to avoid errors in decoders if connection fails.
      urlConnection.connect();
      // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
      stream = urlConnection.getInputStream();
    } catch (IOException e) {
      throw new HttpException(
          "Failed to connect or obtain data", getHttpStatusCodeOrInvalid(urlConnection), e);
    }
	...
	//è¿™é‡Œè·å–è¿”å›code
    final int statusCode = getHttpStatusCodeOrInvalid(urlConnection);
    if (isHttpOk(statusCode)) {
		//å…³æ³¨ç‚¹2
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (isHttpRedirect(statusCode)) {
      String redirectUrlString = urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);
      if (TextUtils.isEmpty(redirectUrlString)) {
        throw new HttpException("Received empty or null redirect url", statusCode);
      }
      URL redirectUrl;
      try {
        redirectUrl = new URL(url, redirectUrlString);
      } catch (MalformedURLException e) {
        throw new HttpException("Bad redirect url: " + redirectUrlString, statusCode, e);
      }
      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
      // to disconnecting the url connection below. See #2352.
      cleanup();
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else if (statusCode == INVALID_STATUS_CODE) {
      throw new HttpException(statusCode);
    } else {
      try {
        throw new HttpException(urlConnection.getResponseMessage(), statusCode);
      } catch (IOException e) {
        throw new HttpException("Failed to get a response message", statusCode, e);
      }
    }
  }

```

//å…³æ³¨ç‚¹1
è¿™é‡Œä¸»è¦æ˜¯åˆ›å»º`HttpUrlConnection`è¯·æ±‚

```java
private HttpURLConnection buildAndConfigureConnection(URL url, Map<String, String> headers)
      throws HttpException {
    HttpURLConnection urlConnection;
    try {
      urlConnection = connectionFactory.build(url);
    } catch (IOException e) {
      throw new HttpException("URL.openConnection threw", /*statusCode=*/ 0, e);
    }
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);
    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
    urlConnection.setInstanceFollowRedirects(false);
    return urlConnection;
}

```

//å…³æ³¨ç‚¹2
è¿”å›æˆåŠŸï¼Œåˆ™è·å–`InputStream`

```java
private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
      throws HttpException {
    try {
      if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
        int contentLength = urlConnection.getContentLength();
        stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
      } else {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());
        }
        stream = urlConnection.getInputStream();
      }
    } catch (IOException e) {
      throw new HttpException(
          "Failed to obtain InputStream", getHttpStatusCodeOrInvalid(urlConnection), e);
    }
    return stream;
}

ç»§ç»­å›åˆ°HttpUrlFeacherçš„loadDataæ–¹æ³•
public void loadData(
      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
	...
	try {
	  InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
	  callback.onDataReady(result);
	} catch (IOException e) {	  
	  callback.onLoadFailed(e);//å¼‚å¸¸å›è°ƒonLoadFailedæ¥å£ç»™åº”ç”¨å±‚
	} finally {
	  ...
	}
}
```

æŠŠè¿”å›çš„`InputStream`é€šè¿‡`callback`å›è°ƒç»™ä¸Šä¸€çº§
è¿™ä¸ªcallback å‰é¢åˆ†æè¿‡ï¼š`callBack = MultiFetcher`
å›åˆ°MultiFetcherçš„`onDataReady`æ–¹æ³•ä¸­ï¼š

```java
public void onDataReady(@Nullable Data data) {
  if (data != null) {
	callback.onDataReady(data);
  } else {
	startNextOrFail();
  }
}
```

çœ‹åˆ°è¿™é‡Œåˆè°ƒç”¨äº†ä¸€æ¬¡callback.onDataReady(data);
è¿™ä¸ªcallback = loadDataä¼ å…¥ä¸‹æ¥çš„`SourceGenerator`ä¸­çš„`startNextLoad`æ–¹æ³•ï¼š

```java
SourceGenerator.java
private void startNextLoad(final LoadData<?> toStart) {
    loadData.fetcher.loadData(
        helper.getPriority(),
        new DataCallback<Object>() {
          @Override
          public void onDataReady(@Nullable Object data) {
            if (isCurrentRequest(toStart)) {
              onDataReadyInternal(toStart, data);
            }
          }

          @Override
          public void onLoadFailed(@NonNull Exception e) {
            if (isCurrentRequest(toStart)) {
              onLoadFailedInternal(toStart, e);
            }
          }
        });
}
```

å›è°ƒè¿™é‡Œå†æ¬¡è°ƒç”¨`onDataReadyInternal`æ–¹æ³•ï¼š

```java
void onDataReadyInternal(LoadData<?> loadData, Object data) {
    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
	//è¿™é‡Œè¡¨ç¤ºæˆ‘ä»¬æ˜¯å¦éœ€è¦è¿›è¡Œç£ç›˜ç¼“å­˜
	if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {
	  dataToCache = data;
	  // We might be being called back on someone else's thread. Before doing anything, we should
	  // reschedule to get back onto Glide's thread.
	  cb.reschedule();
	} else {
	  cb.onDataFetcherReady(
		  loadData.sourceKey,
		  data,
		  loadData.fetcher,
		  loadData.fetcher.getDataSource(),
		  originalKey);
	}
}
```


çœ‹cb.reschedule()æ–¹æ³•ï¼šè¿™ä¸ªcb = `DecodeJob`

```java
DecodeJob.java
public void reschedule() {
    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
    callback.reschedule(this);
}
è¿™ä¸ªcallbackæ˜¯EngineJob
EngineJob.java
public void reschedule(DecodeJob<?> job) {
    // Even if the job is cancelled here, it still needs to be scheduled so that it can clean itself
    // up.
    getActiveSourceExecutor().execute(job);
}
```

åˆ°è¿™é‡Œåˆå»æ‰§è¡Œäº†ä¸€æ¬¡jobï¼Œè¿™ä¸ªjob çš„ `runReason = RunReason.SWITCH_TO_SOURCE_SERVICE`
å‰é¢ç¬¬ä¸€æ¬¡è·å–ç½‘ç»œæ•°æ®ä¹Ÿè°ƒç”¨è¿‡è¿™ä¸ªï¼š
å‰é¢æ˜¯ä¸ºäº†è·å–ç¼“å­˜æ•°æ®ï¼šè¿™æ¬¡æ˜¯ä¸ºäº†å°†æ•°æ®å†™å…¥ç¼“å­˜

æœ€åå°†æ•°æ®é€šè¿‡DecodeJobçš„onDataFetcherReadyå›è°ƒå‡ºå»

è¿™é‡Œå¯¹é˜¶æ®µ2åšä¸€ä¸ªæ€»ç»“ï¼š
- `å·¥ä½œ`ï¼šä¸»è¦è´Ÿè´£å»ç¼“å­˜ä¸­å–æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰å–åˆ°å°±å»ç½‘ç»œæœåŠ¡å™¨æ‹‰æ•°æ®ï¼Œè·å–åˆ°æ•°æ®åï¼Œå°†æ•°æ®æ”¾å…¥åˆ°ç¼“å­˜ä¸­ã€‚
ä½¿ç”¨çš„æ˜¯Jobæ¨¡å¼ï¼Œæ¯ä¸ªJobéƒ½æœ‰ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€å¯¹äºä¸€ä¸ªæ‰§è¡Œå™¨ï¼Œç±»ä¼¼OkHttpä¸­çš„æ‹¦æˆªå™¨æ¨¡å¼


#### `é˜¶æ®µ3`ï¼š**è§£ç æ•°æ®**


```java
public void onDataFetcherReady(
      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
    this.currentSourceKey = sourceKey;
    this.currentData = data;
    this.currentFetcher = fetcher;
    this.currentDataSource = dataSource;
    this.currentAttemptingKey = attemptedKey;
    this.isLoadingFromAlternateCacheKey = sourceKey != decodeHelper.getCacheKeys().get(0);

    if (Thread.currentThread() != currentThread) {
      runReason = RunReason.DECODE_DATA;
      callback.reschedule(this);
    } else {
      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
      try {
        decodeFromRetrievedData();
      } finally {
        GlideTrace.endSection();
      }
    }
}
```

- è¿™ä¸ªæ–¹æ³•ä¸­åˆè°ƒç”¨äº†`decodeFromRetrievedData`
- ä½œç”¨ï¼šè§£ç å¾—åˆ°çš„å“åº”æ•°æ®


```java
private void decodeFromRetrievedData() {
	try {
	  //è¿™é‡Œè§£ç æ•°æ® å…³æ³¨ç‚¹1
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } catch (GlideException e) {
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    }
    if (resource != null) {
	  //é€šçŸ¥åº”ç”¨ å…³æ³¨ç‚¹2
      notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);
    } else {
      runGenerators();
    }
}
```

çœ‹` å…³æ³¨ç‚¹1`ï¼š

```java
decodeFromData
	decodeFromFetcher(data, dataSource);
		runLoadPath(data, dataSource, path);
			path.load(rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
				loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
					result = path.decode(rewinder, width, height, options, decodeCallback);
						decodeResource(rewinder, width, height, options);
							decodeResourceWithList(rewinder, width, height, options, exceptions);
								result = decoder.decode(data, width, height, options);
									downsampler.decode(source, width, height, options);
										decode(...);
											decodeFromWrappedStreams
												Bitmap downsampled = decodeStream(imageReader, options, callbacks, bitmapPool);
													result = imageReader.decodeBitmap(options);
														BitmapFactory.decodeStream(stream(), /* outPadding= */ null, options);
```


å¯ä»¥çœ‹åˆ°è¯·æ±‚æ•°æ®è§£ç è¿‡ç¨‹æœ€åä¹Ÿæ˜¯é€šè¿‡`BitmapFactory.decodeStream`å°†æ•°æ®è½¬æ¢ä¸º`Bitmap`è¿”å›
ä½†æ˜¯è¿™ä¸ªè¿‡ç¨‹ä¸­Glideå¯¹æ•°æ®åšäº†å¤šé‡å¤„ç†ï¼ŒåŒ…æ‹¬`è£å‰ªï¼Œé™é‡‡`æ ·ç­‰æ“ä½œ


å…³æ³¨ç‚¹2ï¼š`notifyEncodeAndRelease`

```java
private void notifyEncodeAndRelease(
	...æ ¸å¿ƒä»£ç 
	notifyComplete(result, dataSource, isLoadedFromAlternateCacheKey);
}
private void notifyComplete(
  Resource<R> resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) {
	setNotifiedOrThrow();
	callback.onResourceReady(resource, dataSource, isLoadedFromAlternateCacheKey);
}
è°ƒç”¨äº†callback.onResourceReadyï¼š
è¿™ä¸ªcallback = EngineJob
EngineJob.java
public void onResourceReady(
      Resource<R> resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) {
	synchronized (this) {
	  this.resource = resource;
	  this.dataSource = dataSource;
	  this.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;
	}
	notifyCallbacksOfResult();
}
void notifyCallbacksOfResult() {
    ...
    for (final ResourceCallbackAndExecutor entry : copy) {
      entry.executor.execute(new CallResourceReady(entry.cb));
    }
    decrementPendingCallbacks();
  }

æ‰§è¡Œäº†CallResourceReadyçš„runæ–¹æ³•
run 
  callCallbackOnResourceReady(cb);
		cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey); cb = SingleRequest
			 onResourceReady
				target.onResourceReady(result, animation); è¿™ä¸ªtarget = BitmapImageViewTarget ï¼Œè¿™é‡Œè°ƒç”¨å…¶çˆ¶ç±»ImageViewTargetçš„onResourceReadyæ–¹æ³•
					setResourceInternal(resource);
						setResource(resource);æ‰§è¡ŒBitmapImageViewTargetçš„setResource
							view.setImageBitmap(resource);åˆ°è¿™é‡Œå°±æ‰§è¡Œå®Œæ¯•äº†
```


- æ€»ç»“é˜¶æ®µ3ï¼šå°±æ˜¯å¯¹ç½‘ç»œæ•°æ®æ ¹æ®éœ€æ±‚è¿›è¡Œé™é‡‡æ ·ï¼Œå¹¶å°†æ•°æ®è®¾ç½®åˆ°å¯¹åº”çš„targetä¸­

è¿™é‡Œå¯¹æ•´ä¸ªæ­¥éª¤3ï¼š`into`æ–¹æ³•åšä¸€ä¸ªæ€»ç»“å§ï¼š
> `é˜¶æ®µ1`ï¼š
> åˆ›å»ºå¯¹åº”çš„ç½‘ç»œè¯·æ±‚ï¼Œå¯¹æ¯”å½“å‰è¯·æ±‚å’Œå†…å­˜ä¸­å‰å‡ ä¸ªè¯·æ±‚æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸€ç›´ï¼Œä½¿ç”¨å‰ä¸€ä¸ªè¯·æ±‚è¿›è¡Œç½‘ç»œè¯·æ±‚ã€‚
> å»ç¼“å­˜ä¸­è·å–å¯¹åº”çš„æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰è·å–åˆ°å°±å»ç½‘ç»œæ‹‰å–æ•°æ®
>
> `é˜¶æ®µ2`ï¼š
> ä¸»è¦è´Ÿè´£å»ç¼“å­˜ä¸­å–æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰å–åˆ°å°±å»ç½‘ç»œæœåŠ¡å™¨æ‹‰æ•°æ®ï¼Œè·å–åˆ°æ•°æ®åï¼Œå°†æ•°æ®æ”¾å…¥åˆ°ç¼“å­˜ä¸­ã€‚
> ä½¿ç”¨çš„æ˜¯Jobæ¨¡å¼ï¼Œæ¯ä¸ªJobéƒ½æœ‰ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€å¯¹äºä¸€ä¸ªæ‰§è¡Œå™¨ï¼Œç±»ä¼¼OkHttpä¸­çš„æ‹¦æˆªå™¨æ¨¡å¼
> æ ¹æ®jobçŠ¶æ€çš„åˆ‡æ¢ï¼Œæ‰§è¡Œå„è‡ªçš„è¯·æ±‚
>
> `é˜¶æ®µ3`ï¼šå¯¹æ•°æ®è¿›è¡Œè§£ç ï¼Œè§£ç ä¼šè¿›è¡Œæ ¹æ®éœ€æ±‚è¿›è¡Œé™é‡‡æ ·ï¼Œå¹¶å°†è·å–çš„å›¾ç‰‡æ•°æ®ä¼ é€’ç»™å¯¹åº”çš„Target



### Glideç¼“å­˜
è¿™é‡Œæˆ‘ä»¬å¯¹`Glideä¸‰çº§ç¼“å­˜`åšä¸€ä¸ªæ€»ç»“ï¼šå› ä¸ºä¸€äº›é¢è¯•è¿˜æ˜¯ç»å¸¸ä¼šé—®åˆ°çš„

1.æ€ä¹ˆç¼“å­˜ï¼Ÿ
å¦‚æœæ”¯æŒç£ç›˜ç¼“å­˜ï¼Œåˆ™å°†åŸ`Source`ç¼“å­˜åˆ°ç£ç›˜ï¼Œåœ¨ç»è¿‡è§£ç å¤„ç†åï¼Œå°†è§£ç åçš„æ•°æ®ç¼“å­˜åˆ°`activeResources`ï¼Œ`activeResources`æ˜¯ä¸€ä¸ª`å¼±å¼•ç”¨çš„å¯¹è±¡`ï¼Œåœ¨å†…å­˜å›æ”¶çš„æ—¶å€™ï¼Œä¼šå°†æ•°æ®æ”¾åˆ°cacheç¼“å­˜ä¸‹é¢

2.æ€ä¹ˆä½¿ç”¨ç¼“å­˜

å¦‚æœç›´æ¥å†…å­˜ç¼“å­˜ï¼Œåˆ™å»`activeResources`ä¸­å–è§£ç åçš„æ•°æ®ï¼Œå¦‚æœ`activeResources`ä¸­æ²¡æœ‰å¯¹åº”çš„ç¼“å­˜ï¼Œåˆ™å»`cache`ç¼“å­˜ä¸­è·å–ï¼Œå¦‚æ‰¾åˆ°åˆ™ç›´æ¥è¿”å›cacheæ•°æ®ï¼Œå¹¶å°†ç¼“å­˜æ•°æ®å†™å…¥activeResourcesä¸­ï¼Œåˆ é™¤cacheä¸­çš„ç¼“å­˜æ•°æ®ï¼Œ
å¦‚æœè¿˜æ²¡æœ‰ï¼Œåˆ™åœ¨è°ƒç”¨ç½‘ç»œè¯·æ±‚å‰ï¼Œå»ç£ç›˜ä¸­è·å–ï¼Œç£ç›˜ä¸­è·å–çš„æ•°æ®æ˜¯å›¾ç‰‡åŸæ•°æ®ï¼Œéœ€è¦ç»è¿‡è§£ç å¤„ç†æ‰èƒ½è¢«æ§ä»¶ä½¿ç”¨ï¼Œç£ç›˜å¦‚æœè¿˜æ²¡æœ‰ï¼Œæ‰ä¼šå»ç½‘ç»œä¸­è¯·æ±‚æ•°æ®ã€‚

ä»¥ä¸Šå°±æ˜¯Glideå¯¹ä¸‰çº§ç¼“å­˜çš„ä½¿ç”¨æœºåˆ¶ã€‚

### æ€»ç»“
æœ€åç”¨ä¸€å¹…å›¾æ¥æ•´ç†ä¸‹è¿‡ç¨‹ï¼šæ¥è‡ª **JsonChao**

å› ä¸ºæ˜¯æ—§ç‰ˆæœ¬ç”»çš„æµç¨‹å›¾ï¼Œæ‰€ä»¥æœ‰äº›åœ°æ–¹å¯èƒ½ä¼šä¸ä¸€è‡´ï¼Œä½†æ˜¯å¤§ä½“æµç¨‹æ˜¯ä¸€è‡´çš„ï¼Œå¯ä»¥å‚è€ƒå›¾ç‰‡å†å»åˆ†ææºç 


![glideæºç åˆ†ææµç¨‹.awebp](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f37bee47dfa4c2ca52dfb1f6c7a847d~tplv-k3u1fbpfcp-watermark.image?)